<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 博客配置</title>
    <url>/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/Hexo-%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本地安装 Git NodeJS</p>
<p>检查环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git -v</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>切换镜像站,具体参考<a href="https://zhuanlan.zhihu.com/p/1903405138527384159">NPM配置国内源</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<h2 id="Hexo环境搭建"><a href="#Hexo环境搭建" class="headerlink" title="Hexo环境搭建"></a>Hexo环境搭建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm install -g hexo-cli                <span class="comment"># 安装Hexo cli工具</span></span><br><span class="line"></span><br><span class="line">hexo init                            <span class="comment"># 初始化博客环境</span></span><br><span class="line">npm install                          <span class="comment"># 安装依赖库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插件</span></span><br><span class="line">npm install hexo-asset-img           <span class="comment"># 头像</span></span><br><span class="line">npm install hexo-auto-category       <span class="comment"># 自动分类</span></span><br><span class="line">npm install hexo-generator-searchdb  <span class="comment"># 生成搜索数据库</span></span><br><span class="line">npm install hexo-backlink            <span class="comment"># Obsdian链接转换</span></span><br><span class="line">npm install hexo-deploy-git          <span class="comment"># git自动发布</span></span><br><span class="line">npm install hexo-theme-next          <span class="comment"># hexo NexT主题</span></span><br><span class="line">npm install hexo-server              <span class="comment"># hexo服务器</span></span><br><span class="line">npm install hexo-next-giscus         <span class="comment"># giscus评论组件</span></span><br><span class="line">npm install hexo-wordcount           <span class="comment"># 字数统计</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">theme: next     # 配置主题next</span><br><span class="line"></span><br><span class="line">giscus:         # 评论配置</span><br><span class="line">  enable: true</span><br><span class="line">  repo:  # Github repository name</span><br><span class="line">  repo_id: # Github repository id</span><br><span class="line">  category: # Github discussion category</span><br><span class="line">  category_id: # Github discussion category id</span><br><span class="line">  # Available values: pathname | url | title | og:title</span><br><span class="line">  mapping: title</span><br><span class="line">  # Available values: 0 | 1</span><br><span class="line">  reactions_enabled: 1</span><br><span class="line">   # Available values: 0 | 1</span><br><span class="line">  emit_metadata: 1</span><br><span class="line">  # Available values: light | light_high_contrast | light_protanopia | light_tritanopia | dark | dark_high_contrast | dark_protanopia | dark_tritanopia | dark_dimmed | preferred_color_scheme | transparent_dark | noborder_light | noborder_dark | noborder_gray | cobalt | purple_dark</span><br><span class="line">  theme: light</span><br><span class="line">  # Available values: en | zh-CN</span><br><span class="line">  lang: zh-CN</span><br><span class="line">  # Place the comment box above the comments</span><br><span class="line">  input_position: bottom</span><br><span class="line">  # Load the comments lazily</span><br><span class="line">  loading: lazy</span><br><span class="line">  </span><br><span class="line">deploy:   # 发布配置</span><br><span class="line">  - type: git</span><br><span class="line">    repo:        # 仓库发布地址</span><br><span class="line">    branch: main # 发布分支</span><br><span class="line">    name:        # git用户名 git config user.name &lt;username&gt;</span><br><span class="line">    email:       # git邮箱 git config user.email &lt;email&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>： 评论部分需要借助Github Discussions, 参考<a href="Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEGiscus%E8%AF%84%E8%AE%BA.md">Hexo博客配置Giscus评论</a></p>
<h2 id="Hexo主题配置"><a href="#Hexo主题配置" class="headerlink" title="Hexo主题配置"></a>Hexo主题配置</h2><p>安装主题后从<code>npm_modules/&lt;主题名&gt;/</code>文件夹中复制<code>_config.yml</code>到博客根目录并重命名为<code>_config.next.yml</code>,当博客deploy时回自动应用主题配置，一下主题修改都基于此文件进行。</p>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>NexT主题支持多种语言，只需要编辑<code>_config.next.yml</code>中的<code>language</code>设置即可</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定示例</th>
</tr>
</thead>
<tbody><tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-CN（注：zh-Hans已经无法使用）</td>
<td>language: zh-CN</td>
</tr>
<tr>
<td>Frangais</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>Portugues</td>
<td>pt</td>
<td>language: pt  <br>或者  <br>language:pt-BR</td>
</tr>
<tr>
<td>繁體中文</td>
<td>zh-hk  <br>或者  <br>zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Pycckmi 93bIK</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>Deutsch</td>
<td>de</td>
<td>language: de</td>
</tr>
<tr>
<td>日本語</td>
<td>ja</td>
<td>language: ja</td>
</tr>
<tr>
<td>Indonesian</td>
<td>id</td>
<td>language: id</td>
</tr>
<tr>
<td>Korean</td>
<td>ko</td>
<td>language: ko</td>
</tr>
<tr>
<td>如果需要添加非内置的字段需要手动添加翻译文件，例如中文的翻译文件路径为<code>node_modules/next/languages/zh-CN.yml</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="设置关于"><a href="#设置关于" class="headerlink" title="设置关于"></a>设置关于</h3><p>在<code>source/about/index.md</code>中添加如下内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line"><span class="section">date: 2025-08-27 00:00:00</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">&lt;个人信息&gt;</span><br></pre></td></tr></table></figure>

<h3 id="选择Scheme"><a href="#选择Scheme" class="headerlink" title="选择Scheme"></a>选择Scheme</h3><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Schem</p>
<ul>
<li>Muse - 默认 Scheme</li>
<li>Mist - Muse 的紧凑版本</li>
<li>Pisces - 双栏 Scheme</li>
<li>Gemini</li>
</ul>
<h3 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h3><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 <a href="http://fontawesome.io/">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu: home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span> </span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span> </span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span> </span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span> </span><br><span class="line"><span class="comment">#schedule: /schedule/ || calendar </span></span><br><span class="line"><span class="comment">#sitemap: /sitemap.xml || sitemap </span></span><br><span class="line"><span class="comment">#commonweal: /404/ || heartbeat </span></span><br><span class="line"><span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>

<p>NexT 默认的菜单项有（标注 <code>* </code>的项表示需要手动创建这个页面）：</p>
<p><strong>注意</strong>: 若站点运行在子目录中，请将链接前缀的 &#x2F; 去掉。</p>
<table>
<thead>
<tr>
<th align="left">键值</th>
<th align="left">设定值</th>
<th align="left">显示文本（简体中文）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">home</td>
<td align="left">home: &#x2F;</td>
<td align="left">主页</td>
</tr>
<tr>
<td align="left">archives</td>
<td align="left">archives: &#x2F;archives</td>
<td align="left">归档页</td>
</tr>
<tr>
<td align="left">categories</td>
<td align="left">categories: &#x2F;categories</td>
<td align="left">分类页<code> *</code></td>
</tr>
<tr>
<td align="left">tags</td>
<td align="left">tags: &#x2F;tags</td>
<td align="left">标签页 <code>*</code></td>
</tr>
<tr>
<td align="left">about</td>
<td align="left">about: &#x2F;about</td>
<td align="left">关于页面<code>*</code></td>
</tr>
<tr>
<td align="left">commonweal</td>
<td align="left">commonweal: &#x2F;404.html</td>
<td align="left">公益 404 !</td>
</tr>
</tbody></table>
<h3 id="侧栏配置"><a href="#侧栏配置" class="headerlink" title="侧栏配置"></a>侧栏配置</h3><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。配置具体如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidbar:</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span>     <span class="comment"># 配置侧栏居左</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span>      <span class="comment"># 侧栏显示行为</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>侧栏显示位置支持</p>
<ul>
<li><code>left</code>:  居左显示</li>
<li><code>right</code>:  居右显示</li>
</ul>
<p>侧栏显示行为支持</p>
<ul>
<li><code>post</code> 默认行为，在文章页面（拥有目录列表）时显示</li>
<li><code>always</code> 所有页面都显示</li>
<li><code>hide</code> 在所有页面中都隐藏（可以手动展开）</li>
<li><code>remove</code> 完全移除</li>
</ul>
<p>注册Github账号,Gitea账号(可选)<br>[^注] Github由于网络问题会经常无法链接，可使用Gitea作为中转，先将代码提交道Gitea，然后Gitea配置自动推送到Github</p>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure>

<p>头像地址如果是以<code>/</code>起始则表示头像图片放置在博客发布后的目录下，例如测试博客地址是<code>http://localhost:4000</code>,头像图片地址为<code>http://localhost:4000/images/avatar.jpg</code><br>此配置需要在博客的<code>source/images</code>目录中放置头像图片<code>avatar.jpg</code></p>
<h3 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/&lt;username&gt; || fab fa-github</span><br><span class="line">  #E-Mail: &lt;email&gt; || fa fa-envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br></pre></td></tr></table></figure>

<p>next主题默认支持的社交链接 <code>||</code>符号后是链接的图标</p>
<p>使用已有配置放开注释即可，如果要添加默认不存在链接示例如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="string">微信:</span> <span class="string">https://wx.qq.com</span> <span class="string">||</span> <span class="string">weixin</span></span><br></pre></td></tr></table></figure>


<p><strong>注意</strong>: 图标对应的名称是FontAwesom图标的名称（不必带 <code>fa-</code> 前缀）</p>
<h3 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward </span></span><br><span class="line"><span class="attr">reward:</span> </span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/custom/wechatpay.jpg</span> </span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/custom/alipay.jpg</span> </span><br></pre></td></tr></table></figure>
<p>放开此部分注释并在<code>source/images</code>中放入收款码图片</p>
<h3 id="站点建立时间"><a href="#站点建立时间" class="headerlink" title="站点建立时间"></a>站点建立时间</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2025</span></span><br></pre></td></tr></table></figure>

<h3 id="订阅微信公众号"><a href="#订阅微信公众号" class="headerlink" title="订阅微信公众号"></a>订阅微信公众号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Wechat Subscriber </span><br><span class="line">wechat_subscriber: </span><br><span class="line">  enabled: true </span><br><span class="line">  qcode: /images/wechat-qcode.jpg </span><br><span class="line">  description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！</span><br></pre></td></tr></table></figure>
<p>放开此部分注释，并在<code>source/images</code>中放入公众号二维码</p>
<p><strong>注意</strong>: 此功能需要NexT版本在5.0.1之后</p>
<h3 id="设置动画"><a href="#设置动画" class="headerlink" title="设置动画"></a>设置动画</h3><p>NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 <code>false</code> 来关闭动画。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Use velocity to animate everything. </span><br><span class="line">motion: </span><br><span class="line">  enable: true </span><br><span class="line">  async: true </span><br><span class="line">  transition: </span><br><span class="line">    # Transition variants: </span><br><span class="line">    # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut </span><br><span class="line">    # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut </span><br><span class="line">    # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut </span><br><span class="line">    # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut </span><br><span class="line">    # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut </span><br><span class="line">    # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut </span><br><span class="line">    post_block: fadeIn </span><br><span class="line">    post_header: slideDownIn </span><br><span class="line">    post_body: slideDownIn </span><br><span class="line">    coll_header: slideLeftIn # Only for Pisces | Gemini. </span><br><span class="line">    sidebar: slideUpIn</span><br></pre></td></tr></table></figure>

<h3 id="设置全文阅读"><a href="#设置全文阅读" class="headerlink" title="设置全文阅读"></a>设置全文阅读</h3><p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。</p>
<ul>
<li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式 <strong>推荐</strong>。</li>
<li>在文章的 front-matter 中添加 description，并提供文章摘录</li>
<li>自动形成摘要，需要添加如下配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend. </span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately. </span></span><br><span class="line"><span class="attr">auto_excerpt:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置字数统计-阅读时长"><a href="#设置字数统计-阅读时长" class="headerlink" title="设置字数统计&#x2F;阅读时长"></a>设置字数统计&#x2F;阅读时长</h3><p>在<code>_config.yml</code>中配置如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings </span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount </span></span><br><span class="line"><span class="attr">post_wordcount:</span> </span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>在<code>_config.yml</code>中配置如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-generator-searchdb </span></span><br><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span> </span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> </span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span> </span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>在_config.next.yml中配置如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search </span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search </span></span><br><span class="line"><span class="attr">local_search:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input </span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button   </span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span> </span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1 </span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>参考<br><a href="https://hexo.io/zh-cn/docs/">官方文档</a><br><a href="https://jiz4oh.com/2020/09/hexo-next/">Hexo 博客使用 Next 主题及美化 | Jiz4oh’s Life</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>静态博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客配置Giscus评论</title>
    <url>/2025/08/27/Hexo%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEGiscus%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<p>参考<br><a href="https://weilado.github.io/2025/06/18/%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9F%BA%E4%BA%8Egiscus%EF%BC%89/">如何为博客添加评论系统（基于giscus） | 栞的图书馆</a><br><a href="https://blog.csdn.net/sinat_41212418/article/details/137819858">5分钟，为你的博客增加评论功能_giscus-CSDN博客</a><br><a href="https://mrh233.github.io/2024/04/17/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Egiscus%E9%85%8D%E7%BD%AE%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/">如何基于giscus配置评论功能 - 奕皓的个人博客</a></p>
<p><a href="https://blog.lanweihong.com/posts/24011/">Hexo NexT 主题使用 utterances 搭建评论系统 | 蓝伟洪的博客</a><br><a href="https://toypipi.github.io/2024/06/21/Hexo-Next-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE-utterances-%E8%AF%84%E8%AE%BA/">Hexo NexT 主题配置 utterances 评论 | Toypipi’s blog</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo 增加站内文章链接</title>
    <url>/2024/08/29/Hexo%E5%8D%9A%E5%AE%A2/Hexo-%E5%A2%9E%E5%8A%A0%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="使用markdown的链接语法"><a href="#使用markdown的链接语法" class="headerlink" title="使用markdown的链接语法"></a>使用markdown的链接语法</h3><p>使用markdown的语法指定url创建站内链接，有绝对地址和相对地址两种方式，绝对地址与相对地址的区别在于是否以<code>/</code>开头：</p>
<h4 id="使用绝对地址"><a href="#使用绝对地址" class="headerlink" title="使用绝对地址"></a>使用绝对地址</h4><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 格式 [<span class="string">标题</span>](<span class="link">文章地址</span>)</span></span><br><span class="line">[<span class="string">Hexo 增加站内文章链接</span>](<span class="link">/Hexo博客/Hexo-增加站内文章链接</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例中，<code>Hexo-增加站内文章链接</code>使用的是文章对应的md文件名，使用hexo n创建post时，空格会转换为中划线-。<code>/Hexo</code>是为了文章管理方便在<code>_posts</code>目录下增加的子目录，<code>Hexo-增加站内文章链接.md</code>位于<code>_posts/Hexo/</code>目录下。</p>
</blockquote>
<p>结果如下：</p>
<p><a href="/Hexo%E5%8D%9A%E5%AE%A2/Hexo-%E5%A2%9E%E5%8A%A0%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5">Hexo 增加站内文章链接</a></p>
<p>Hexo对绝对地址和相对地址的处理方式是不一样的。对于绝对地址<code>/Hexo/Hexo-博客配置</code>，生成的目标url不会变化。</p>
<h4 id="使用相对地址"><a href="#使用相对地址" class="headerlink" title="使用相对地址"></a>使用相对地址</h4><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Hexo 增加站内文章链接](Hexo/Hexo-增加站内文章链接)</span><br></pre></td></tr></table></figure>

<p>对于相对地址<code>Hexo/Hexo-增加站内文章链接</code>，生成的目标URL会叠加文章的的URL，结果是<code>/Hexo/Hexo/Hexo-增加站内文章链接</code>，这显然不是期望的结果。但是如果是文章内的锚点链接，使用这种方式非常合适。</p>
<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 格式 [<span class="string">标题</span>](<span class="link">#文章内要跳转的标题</span>)</span></span><br><span class="line">[<span class="string">测试文章内跳转锚点</span>](<span class="link">#测试文章内跳转锚点</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%E5%86%85%E8%B7%B3%E8%BD%AC%E9%94%9A%E7%82%B9">跳转文章内测试锚点</a></p>
<p>生成的URL可以正确的跳转到文章内的锚点。注意，标题中的空格用<code>-</code>代替。</p>
<h3 id="使用post-link标签"><a href="#使用post-link标签" class="headerlink" title="使用post_link标签"></a>使用post_link标签</h3><p>由于Hexo文章的URL规则是可以配置的，在<code>_config.yml</code>中可以配置URL自动添加日期、目录等信息。如果使用markdown语法的链接规则多有不便，一方面需要知道目标URL，一方面如果规则修改或者站点迁移，对应的内容需要修改。</p>
<p>好在Hexo提供了<code>post_link</code>标签解决这个问题。</p>
<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 格式 &#123;% post<span class="emphasis">_link 以_</span>post下文件路径 &#x27;显示链接名&#x27;%&#125;</span></span><br><span class="line">&#123;% post<span class="emphasis">_link Hexo博客/Hexo-博客配置 &#x27;Hexo 博客配置&#x27; %&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例中，<code>Hexo-博客配置</code>使用的是文章对应的md文件名，使用hexo n创建post时，空格会转换为中划线-。<code>Hexo</code>是为了文章管理方便在<code>_posts</code>目录下增加的子目录，<code>Hexo-博客配置.md</code>位于<code>_posts/Hexo</code>目录下。</p>
</blockquote>
<p>结果如下：</p>
<a href="/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/Hexo-%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/" title="Hexo 博客配置">Hexo 博客配置</a>

<p>这样的链接会自动适配<code>_config.yml</code>中的文章URL规则。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对比markdown语法和<code>post_link</code>标签，推荐在文章链接到站内文章时优先使用<code>post_link</code>，链接到文章内锚点时优先使用markdown语法。</p>
<h3 id="测试文章内跳转锚点"><a href="#测试文章内跳转锚点" class="headerlink" title="测试文章内跳转锚点"></a>测试文章内跳转锚点</h3><p>文章内锚点跳转示例</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>静态博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GithubActions部署Hexo博客</title>
    <url>/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Github-Actions%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为技术博主，博客的高效维护与部署一直是我关注的重点。近期在维护博客时，我遇到了两个核心问题：</p>
<ol>
<li><strong>内容管理混乱</strong>：草稿箱文件堆积，缺乏分类标准，甚至因误操作破坏了原有配置；</li>
<li><strong>兼容性局限</strong>：计划将文章同步至 FastGPT 等 AI 知识库时，发现官方推荐的 Hexo 部署方案（源码与静态文件混存）中，冗余的 <code>public</code> 目录会干扰 RAG 系统提取内容，且源码与发布产物耦合易引发冲突。</li>
</ol>
<p>为解决这些问题，我采用了<strong>源码与发布分离</strong>的部署架构：将 Markdown 源文件单独存放在一个仓库，通过 GitHub Actions 自动在另一个仓库构建并发布静态文件。这种方式的优劣对比如下：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>官方混仓部署</td>
<td>支持本地手动 &#x2F; 自动发布，预览方便，配置简单</td>
<td>仓库体积大，源码与产物混合，不利于二次利用</td>
</tr>
<tr>
<td>本文分离部署</td>
<td>源码纯净、产物独立，兼容 AI 知识库，自动构建</td>
<td>本地预览需搭测试环境，配置较复杂（双仓库 + 鉴权）</td>
</tr>
</tbody></table>
<h2 id="部署核心思路"><a href="#部署核心思路" class="headerlink" title="部署核心思路"></a>部署核心思路</h2><p>核心逻辑：当源码仓库收到推送时，GitHub Actions 自动将源文件检出到 <code>source/_posts</code>，并从 <code>_hexo</code> 目录复制配置文件还原 Hexo 环境，最终执行构建与发布。</p>
<p><strong>文件结构设计</strong>（源码仓库）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- _hexo/ # Hexo 核心配置目录 </span><br><span class="line">| |-- _config.yml # Hexo 主配置 </span><br><span class="line">| |-- _config.next.yml # NexT 主题配置 </span><br><span class="line">| |-- package.json # Node 环境依赖 </span><br><span class="line">| |-- scaffolds/ # 文章模板（draft/page/post.md） </span><br><span class="line">| |-- static/ # 静态资源（头像、支付码等） </span><br><span class="line">|-- .github/workflows/ # GitHub Actions 工作流配置 </span><br><span class="line">|-- .obsidian/ # Obsidian 编辑器配置（可选）</span><br></pre></td></tr></table></figure>

<h2 id="详细部署步骤"><a href="#详细部署步骤" class="headerlink" title="详细部署步骤"></a>详细部署步骤</h2><h3 id="1-生成-SSH-密钥对（用于仓库间鉴权）"><a href="#1-生成-SSH-密钥对（用于仓库间鉴权）" class="headerlink" title="1. 生成 SSH 密钥对（用于仓库间鉴权）"></a>1. 生成 SSH 密钥对（用于仓库间鉴权）</h3><p>需要生成一对 SSH 密钥，用于源码仓库向发布仓库推送构建结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;&lt;github 注册邮箱&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行后会在以下路径生成两个文件：</p>
<ul>
<li>私钥：<code>~/.ssh/id_rsa</code>（Linux&#x2F;Mac）或 <code>C:\Users\&lt;用户名&gt;\.ssh\id_rsa</code>（Windows）</li>
<li>公钥：<code>~/.ssh/id_rsa.pub</code>（同上路径）</li>
</ul>
<p><strong>注意</strong>：.ssh为隐藏目录，需要修改系统设置显示此文件夹</p>
<img src="/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Github-Actions%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/IMG-20250827165137638.png" class="">

<h3 id="2-准备两个仓库"><a href="#2-准备两个仓库" class="headerlink" title="2. 准备两个仓库"></a>2. 准备两个仓库</h3><h4 id="仓库-1：源码仓库（存放-Markdown-与配置）"><a href="#仓库-1：源码仓库（存放-Markdown-与配置）" class="headerlink" title="仓库 1：源码仓库（存放 Markdown 与配置）"></a>仓库 1：源码仓库（存放 Markdown 与配置）</h4><ul>
<li>新建仓库（例如命名为 <code>hexo-source</code>）</li>
<li>进入仓库设置：<code>Settings → Secrets and variables → Actions → New repository secret</code></li>
<li>添加一个名为 <code>HEXO_DEPLOY_KEY</code> 的密钥，值为<strong>私钥 <code>id_rsa</code> 的内容</strong>（用记事本打开复制）</li>
</ul>
<img src="/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Github-Actions%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/IMG-20250827165137689.png" class="">

<img src="/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Github-Actions%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/IMG-20250827165137708.png" class="">


<h4 id="仓库-2：发布仓库（存放静态文件，用于-GitHub-Pages）"><a href="#仓库-2：发布仓库（存放静态文件，用于-GitHub-Pages）" class="headerlink" title="仓库 2：发布仓库（存放静态文件，用于 GitHub Pages）"></a>仓库 2：发布仓库（存放静态文件，用于 GitHub Pages）</h4><ul>
<li>仓库名必须为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>（固定格式，否则 GitHub Pages 无法生效）</li>
<li>权限需设为<strong>公开</strong>，并开启 <code>Discussions</code> 功能（进入仓库设置 → <code>Features</code> 勾选）</li>
<li>配置部署密钥：<code>Settings → Deploy keys → Add deploy key</code><ul>
<li>Title 填 <code>HEXO_DEPLOY_PUB</code></li>
<li>Key 填入<strong>公钥 <code>id_rsa.pub</code> 的内容</strong>，并勾选 <code>Allow write access</code>（允许推送权限）</li>
</ul>
</li>
</ul>
<img src="/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Github-Actions%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/IMG-20250827165137733.png" class="">

<img src="/2021/10/22/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Github-Actions%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/IMG-20250827165137761.png" class="">
<h3 id="3-配置-Hexo-环境文件"><a href="#3-配置-Hexo-环境文件" class="headerlink" title="3. 配置 Hexo 环境文件"></a>3. 配置 Hexo 环境文件</h3><p>在源码仓库中创建 <code>_hexo</code> 目录，放入以下核心文件（可从本地 Hexo 环境中复制, 参考<a href="Hexo-%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE.md">Hexo-博客配置</a>）：</p>
<ul>
<li><code>_config.yml</code>：Hexo 主配置（需修改部署相关配置，见步骤 4）</li>
<li><code>_config.next.yml</code>：NexT 主题配置（其他主题同理）</li>
<li><code>package.json</code>：依赖配置（需包含 <code>hexo</code>、<code>hexo-deployer-git</code> 等核心依赖）</li>
<li><code>scaffolds/</code>：文章模板（<code>draft.md</code>&#x2F;<code>page.md</code>&#x2F;<code>post.md</code>）</li>
<li>静态资源：如头像（<code>avatar.jpg</code>）、关于页（<code>about.md</code>）等，按实际需求存放</li>
</ul>
<h3 id="4-配置部署与工作流文件"><a href="#4-配置部署与工作流文件" class="headerlink" title="4. 配置部署与工作流文件"></a>4. 配置部署与工作流文件</h3><h4 id="①-Hexo-部署配置（-hexo-config-yml）"><a href="#①-Hexo-部署配置（-hexo-config-yml）" class="headerlink" title="① Hexo 部署配置（_hexo/_config.yml）"></a>① Hexo 部署配置（<code>_hexo/_config.yml</code>）</h4><p>在配置文件中添加部署规则，指向发布仓库：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;username&gt;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">&lt;email&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="②-GitHub-Actions-工作流（-github-workflows-hexo-deploy-yml）"><a href="#②-GitHub-Actions-工作流（-github-workflows-hexo-deploy-yml）" class="headerlink" title="② GitHub Actions 工作流（.github/workflows/hexo-deploy.yml）"></a>② GitHub Actions 工作流（<code>.github/workflows/hexo-deploy.yml</code>）</h4><p>创建工作流文件，实现自动构建部署：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">hexo-deploy</span>  <span class="comment"># 工作流名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发条件：向 master 分支推送时执行</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">&quot;master&quot;</span>]</span><br><span class="line">    </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span>  <span class="comment"># 使用 Ubuntu 环境</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 1. 配置时区（避免时间显示异常）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Timezone</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">szenius/set-timezone@v2.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">timezoneLinux:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 2. 拉取源码仓库内容到 source/_posts</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">source/_posts</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 3. 安装 Node.js（需与本地开发环境版本一致，这里用 20.x）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;20&#x27;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 4. 缓存 NPM 依赖（加速构建）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      </span><br><span class="line">      <span class="comment"># 5. 配置 SSH 密钥（用于向发布仓库推送）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span>  <span class="comment"># 引用源码仓库的私钥</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa  # 严格权限，否则 SSH 会拒绝使用</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts  # 信任 GitHub 主机</span></span><br><span class="line"><span class="string"></span>      </span><br><span class="line">      <span class="comment"># 6. 拉取主题（以 NexT 为例，其他主题修改仓库地址即可）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Themes</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">next-theme/hexo-theme-next</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">themes/next</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 7. 还原 Hexo 环境（从 _hexo 目录复制配置文件）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install -g hexo-cli  # 全局安装 Hexo 命令行工具</span></span><br><span class="line"><span class="string">          # 复制核心配置文件</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/_config.yml .</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/_config.next.yml .</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/package.json .</span></span><br><span class="line"><span class="string">          # 复制文章模板</span></span><br><span class="line"><span class="string">          mkdir scaffolds</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/scaffolds/* scaffolds/</span></span><br><span class="line"><span class="string">          # 复制静态页面（关于页、分类页等，按实际需求调整）</span></span><br><span class="line"><span class="string">          mkdir -p source/about source/categories source/tags source/images</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/about.md source/about/index.md</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/categories.md source/categories/index.md</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/tags.md source/tags/index.md</span></span><br><span class="line"><span class="string">          cp source/_posts/_hexo/*.jpg source/images/  # 复制图片资源</span></span><br><span class="line"><span class="string">          # 安装依赖</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span>      </span><br><span class="line">      <span class="comment"># 8. 缓存部署目录（加速后续构建）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.deploy_git</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-deploy-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-deploy-cache</span></span><br><span class="line"><span class="string"></span>      </span><br><span class="line">      <span class="comment"># 9. 构建并发布</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd .deploy_git &amp;&amp; git pull  # 拉取最新发布内容，避免冲突</span></span><br><span class="line"><span class="string">          cd ..</span></span><br><span class="line"><span class="string">          hexo clean  # 清理缓存</span></span><br><span class="line"><span class="string">          hexo generate  # 生成静态文件</span></span><br><span class="line"><span class="string">          hexo deploy  # 部署到发布仓库</span></span><br></pre></td></tr></table></figure>

<h2 id="验证与使用"><a href="#验证与使用" class="headerlink" title="验证与使用"></a>验证与使用</h2><ol>
<li>将上述文件提交到源码仓库的 <code>master</code> 分支，GitHub Actions 会自动触发工作流；</li>
<li>进入源码仓库的 <code>Actions</code> 标签页，查看工作流执行状态，若显示绿色对勾则部署成功；</li>
<li>访问 <code>https://&lt;你的用户名&gt;.github.io</code>，即可看到最新发布的博客。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>私钥 <code>HEXO_DEPLOY_KEY</code> 是敏感信息，切勿泄露或提交到仓库；</li>
<li>发布仓库名必须严格为 <code>&lt;用户名&gt;.github.io</code>，否则 GitHub Pages 无法正常访问；</li>
<li>若主题是自定义修改过的，建议将主题 fork 到自己的仓库，再在工作流中拉取自己的 fork 版本；</li>
<li>本地预览时，可在源码仓库中手动搭建 Hexo 环境（复制 <code>_hexo</code> 目录文件，执行 <code>hexo server</code>）。</li>
</ol>
<p>参考</p>
<p><a href="https://hexo.io/zh-cn/docs/github-pages">Hexo官方提供的Github Actions部署示例</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>静态博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Obsidian配合Hexo写博客</title>
    <url>/2024/09/20/Hexo%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8Obsidian%E9%85%8D%E5%90%88Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>参考<br><a href="https://zhuanlan.zhihu.com/p/688561305">【2024】从零开始用Hexo+GithubPage搭建个人网站（保姆级） - 知乎 (zhihu.com)</a><br><a href="https://segmentfault.com/a/1190000042111566">Hexo + Obsidian + Git 完美的博客部署与编辑方案 - 个人文章 - SegmentFault 思否</a><br><a href="https://zhuanlan.zhihu.com/p/554333805">Obsidian+Git完美维护Hexo博客 - 知乎 (zhihu.com)</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>静态博客</tag>
        <tag>Obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核TCP网络参数.md</title>
    <url>/2024/12/11/Linux/Linux%E5%86%85%E6%A0%B8TCP%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.d/99-sysctl.conf：     #重启后生效</span><br><span class="line">fs.inotify.max_user_watches = 600000</span><br><span class="line">dev.i915.perf_stream_paranoid = 0</span><br><span class="line">vm.swappiness = 1</span><br><span class="line">net.ipv6.conf.all.accept_ra = 2</span><br><span class="line">fs.file-max = 6553560</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line">net.core.optmem_max = 10000000</span><br><span class="line">net.core.netdev_max_backlog = 8096</span><br><span class="line">net.core.somaxconn = 8096</span><br><span class="line">net.ipv4.ip_default_ttl = 128</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = 0</span><br><span class="line">net.ipv4.route.gc_timeout = 100</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_ecn = 1</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line">net.ipv4.tcp_fack = 1</span><br><span class="line">net.ipv4.tcp_low_latency = 0</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line">net.ipv4.tcp_frto = 2</span><br><span class="line">net.ipv4.tcp_frto_response = 0</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = 0</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 30000</span><br><span class="line">net.ipv4.tcp_max_orphans = 262114</span><br><span class="line">net.ipv4.netfilter.ip_conntrack_max = 204800</span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line"># for high-latency network Google BBR    #个人PC不建议开启BBR，对网速不会有提升，还会降低wifi吞吐量；还是等BBR2正式版出了再开启BBR2吧，BBR2对wifi就没有影响了</span><br><span class="line">#net.ipv4.tcp_congestion_control = bbr</span><br><span class="line">net.core.default_qdisc = fq_codel</span><br><span class="line">net.ipv4.tcp_congestion_control = cubic</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 0</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 0</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 0</span><br><span class="line">net.ipv6.ip_default_ttl = 128</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/security/limits.conf：</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft noproc 65536 </span><br><span class="line">* hard noproc 65536</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL生成自签名证书</title>
    <url>/2024/09/03/Linux/OpenSSL%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><h5 id="CA-Certificate-Authority"><a href="#CA-Certificate-Authority" class="headerlink" title="CA(Certificate Authority)"></a>CA(Certificate Authority)</h5><p>证书授权机构,  负责发放和管理数字证书的权威机构，有自己的证书，可以拿自己的证书给别人签名。</p>
<h5 id="RootCA"><a href="#RootCA" class="headerlink" title="RootCA"></a>RootCA</h5><p>根证书，权威机构持有的证书，安装根证书意味着对这个证书机构的信任，所有其他证书都由这个根证书来签发。只需要把这个根证书添加到受信任的根证书，所有其他由此根证书签发的证书都会被自动信任。</p>
<h5 id="SubCA"><a href="#SubCA" class="headerlink" title="SubCA"></a>SubCA</h5><p>中间证书机构，由权威机构签发的证书，</p>
<h5 id="CSR-Certificate-Signing-Request"><a href="#CSR-Certificate-Signing-Request" class="headerlink" title="CSR(Certificate Signing Request)"></a>CSR(Certificate Signing Request)</h5><p>证书请求文件，证书申请者在申请数字证书时生成私钥的同时也生成证书请求文件，证书申请者只要把CSR文件提交给证书颁发机构后，证书颁发机构使用其根证书给私钥签名就生成了证书公钥文件，也就是颁发给用户的证书。</p>
<h5 id="常用后缀名"><a href="#常用后缀名" class="headerlink" title="常用后缀名"></a>常用后缀名</h5><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.crt,.cer</td>
<td>证书文件</td>
</tr>
<tr>
<td>.key</td>
<td>私钥文件</td>
</tr>
<tr>
<td>.csr</td>
<td>证书签名请求文件</td>
</tr>
<tr>
<td>.pem</td>
<td>base64编码证书文件,可以单独放证书或密钥，也可以同时放两个。Apache 和 NGINX 服务器偏向于使用这种编码格式，也是 openssl 默认采用的信息存放方式。</td>
</tr>
<tr>
<td>.der</td>
<td>二进制证书文件，可包含所有私钥、公钥和证书，是大多数浏览器的缺省格式，常见于 Windows 系统中的证书格式。</td>
</tr>
</tbody></table>
<h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>在证书链中，通常分为三级结构，分别是根证书、中间证书、服务器证书。正确的证书链顺序中服务器证书处在最底端，里面包含服务器域名域名服务器公钥和签名值等。服务器证书的上一级是中间证书，可以由多张证书组合在一起，最上级是根证书。对服务器身份进行校验时，需要验证一整个证书链。每一级证书都有签名值，根证书使用自己的根CA公钥验证自己的签名，也用来验证中间证书的签名值，中间证书的公钥用来验证下一级证书的签名值。</p>
<img src="/2024/09/03/Linux/OpenSSL%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/IMG-20250908095942730.png" class="">


<h4 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h4><h5 id="生成根私钥"><a href="#生成根私钥" class="headerlink" title="生成根私钥"></a>生成根私钥</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成CA认证机构的证书密钥</span></span><br><span class="line"><span class="comment"># 需要设置密码(输入两次)</span></span><br><span class="line">openssl genrsa -des3 -out root-ca.priv.key 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除密钥里的密码,有密码的话每次使用的时候都要输入密码才能使用。</span></span><br><span class="line"><span class="comment"># 需要再输入一次上一步的密码</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> root-ca.priv.key -out root-ca.key</span><br></pre></td></tr></table></figure>

<p>第一次生成的私钥，是带有 passphrase 的。这带来一个副作用，就是需要在使用过程中输入密码。这对于一些特定场景来说会带来一些问题。比如：Apache 的自动启动过程，或者一些工具，甚至有没有提供输入 passphrase 的机会。其实是<strong>可以将 3DES 的加密从秘钥中移除</strong>的，这样，使用的过程中就不再需要输入 passphrase。这也带来另一个问题，如果其他人获取到了未加密的私钥，对应的证书也需要被吊销，以避免带来危害。</p>
<h5 id="生成自签名的根证书请求"><a href="#生成自签名的根证书请求" class="headerlink" title="生成自签名的根证书请求"></a>生成自签名的根证书请求</h5><p>-subj 参考<a href="#%E8%AF%81%E4%B9%A6%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">证书请求文件参数说明</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成根证书自签名请求</span></span><br><span class="line">openssl req -new -key root-ca.key \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Tianjin/L=Tianjin/O=Example/OU=DEV/CN=Example Root&quot;</span> \</span><br><span class="line">    -out root-ca.csr </span><br></pre></td></tr></table></figure>

<h5 id="生成自签名根证书"><a href="#生成自签名根证书" class="headerlink" title="生成自签名根证书"></a>生成自签名根证书</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -x509	使用X.509证书结构生成证书，X.509 证书的结构是用 ASN1(Abstract Syntax Notation One)进行描述数据结构。</span></span><br><span class="line"><span class="comment"># -days 证书有效期,按天来算</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> root-ca.csr -signkey root-ca.key -out root-ca.crt -days 3650</span><br></pre></td></tr></table></figure>



<h4 id="生成中间证书"><a href="#生成中间证书" class="headerlink" title="生成中间证书"></a>生成中间证书</h4><p><strong>如果不是复杂场景可以跳过此步骤，使用根证书直接生成客户端证书</strong></p>
<p> 使用root-ca签发sub-ca的证书签名请求,中间证书指的是可以允许继续生成下级证书，否则的话默认生成终端证书，即使可以用中间证书生成下一级客户端和服务端等用户证书，最终验证的无法通过。</p>
<h5 id="生成中间证书私钥"><a href="#生成中间证书私钥" class="headerlink" title="生成中间证书私钥"></a>生成中间证书私钥</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成私钥,方式1(参考根证书私钥)</span></span><br><span class="line">openssl genrsa -des3 -out mid-ca.priv.key 4096</span><br><span class="line">openssl rsa -<span class="keyword">in</span> mid-ca.priv.key -out mid-ca.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥,方式2</span></span><br><span class="line">openssl genpkey -algorithm RSA -out mid-ca.key -pkeyopt rsa_keygen_bits:4096</span><br></pre></td></tr></table></figure>

<h5 id="生成中间证书请求"><a href="#生成中间证书请求" class="headerlink" title="生成中间证书请求"></a>生成中间证书请求</h5><p>-subj参考<a href="#%E8%AF%81%E4%B9%A6%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">证书请求文件参数说明</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成中间证书自签名请求</span></span><br><span class="line">openssl req -new -key root-ca.key \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Tianjin/L=Tianjin/O=Example/OU=DEV/CN=Example Root&quot;</span> \</span><br><span class="line">    -out mid-ca.csr </span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时生成key和csr</span></span><br><span class="line">openssl req -new -newkey rsa:4096 -nodes -keyout mid-ca.key -out mid-ca.csr \</span><br><span class="line">    -subj=<span class="string">&quot;/C=CN/ST=Tianjin/L=Tianjin/O=Example/OU=DEV/CN=Example Mid&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="生成中间证书-1"><a href="#生成中间证书-1" class="headerlink" title="生成中间证书"></a>生成中间证书</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">openssl x509 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">&quot;subjectKeyIdentifier=hash\nauthorityKeyIdentifier=keyid:always,issuer:always&quot;</span>) \</span><br><span class="line">    -days 3650 -<span class="keyword">in</span> mid-ca.csr -CA root-ca.crt -CAkey root-ca.key \</span><br><span class="line">    -CAcreateserial -out mid-ca.crt</span><br></pre></td></tr></table></figure>

<h5 id="验证中间证书"><a href="#验证中间证书" class="headerlink" title="验证中间证书"></a>验证中间证书</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl verify -CAfile root-ca.crt mid-ca.crt</span><br></pre></td></tr></table></figure>



<h4 id="生成终端证书"><a href="#生成终端证书" class="headerlink" title="生成终端证书"></a>生成终端证书</h4><p>假设服务器域名为<code>example.io</code></p>
<h5 id="生成终端证书私钥"><a href="#生成终端证书私钥" class="headerlink" title="生成终端证书私钥"></a>生成终端证书私钥</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成私钥，方式1(参考根证书私钥)</span></span><br><span class="line">openssl genrsa -des3 -out example.io.priv.key 4096</span><br><span class="line">openssl rsa -<span class="keyword">in</span> example.io.priv.key -out example.io.priv.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥，方式2</span></span><br><span class="line">openssl genpkey -algorithm RSA -out example.io.key -pkeyopt rsa_keygen_bits:4096</span><br></pre></td></tr></table></figure>



<h5 id="生成终端证书请求"><a href="#生成终端证书请求" class="headerlink" title="生成终端证书请求"></a>生成终端证书请求</h5><p>-subj 参考<a href="#%E8%AF%81%E4%B9%A6%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">证书请求文件参数说明</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成终端证书自签名请求</span></span><br><span class="line">openssl req -new -key example.io.key -out example.io.csr -subj=<span class="string">&quot;/CN=example.io&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="生成终端证书-1"><a href="#生成终端证书-1" class="headerlink" title="生成终端证书"></a>生成终端证书</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 生成证书,如果不使用中间证书可把mid-ca.crt替换为root-ca.crt</span></span><br><span class="line">openssl x509 -req -days 3650 \</span><br><span class="line">    -extfile v3.ext</span><br><span class="line">    -CA root-ca.crt -CAkey root-ca.key -CAcreateserial \</span><br><span class="line">    -<span class="keyword">in</span> example.io.csr -signkey example.io.key \</span><br><span class="line">    -out example.io.crt</span><br><span class="line">    </span><br><span class="line">openssl x509 -req -extfile v3.ext -days 365 -<span class="keyword">in</span> example.io.csr -CA mid-ca.crt -CAkey mid-ca.key -CAcreateserial -out example.io.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出pfx,</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out example.io.pfx -inkey example.io.key -<span class="keyword">in</span> example.io.crt</span><br></pre></td></tr></table></figure>

<p>v3.ext参考<a href="#X.509%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE">X.509扩展配置</a></p>
<p><strong>注意:</strong> v3.ext中<code>basicConstraints=CA:FALSE</code>为必选项，否则生成证书无法使用</p>
<h5 id="验证终端证书"><a href="#验证终端证书" class="headerlink" title="验证终端证书"></a>验证终端证书</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl verify -CAfile root-ca.crt example.io.crt</span><br></pre></td></tr></table></figure>



<h4 id="查看证书信息"><a href="#查看证书信息" class="headerlink" title="查看证书信息"></a>查看证书信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看公钥的内容,如果为.PEM ,则会以 base 64 明文方式显示</span></span><br><span class="line">openssl rsa -noout -text -<span class="keyword">in</span> cakey.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看证书的内容命令为</span></span><br><span class="line">openssl x509 -noout -text -<span class="keyword">in</span> cacert.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 证书编码格式转换</span></span><br><span class="line"><span class="comment"># PEM 转为 DER</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> cacert.crt -outform der -out cacert.der</span><br><span class="line"><span class="comment"># DER 转为 PEM</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> cert.crt -inform der -outform pem -out cacert.pem</span><br></pre></td></tr></table></figure>



<h4 id="证书有效性验证"><a href="#证书有效性验证" class="headerlink" title="证书有效性验证"></a>证书有效性验证</h4><p>可以利用<code>openssl</code> 的<code>s_server</code>命令来模拟一个服务端，要使用到证书管理员生成的证书<code>client.crt</code>，以及申请人在创建<code>csr</code>时生成的 <code>client.key</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl s_server -cert example.io.crt -key example.io.key -debug -HTTP -accept 443</span><br></pre></td></tr></table></figure>

<p>然后浏览器访问 <code>https://ip地址</code>来查看证书是否有效（要先导入根证书到</p>
<p>信任的根证书颁发机构）。</p>
<h4 id="吊销证书"><a href="#吊销证书" class="headerlink" title="吊销证书"></a>吊销证书</h4><p>一般由于用户私钥泄露等情况才需要吊销一个未过期的证书。</p>
<p>假设需要被吊销的证书文件为 <code>cert.pem</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书吊销列表文件</span></span><br><span class="line"><span class="comment"># 可选参数</span></span><br><span class="line"><span class="comment">#   -crldays 下一个吊销列表将在n天后发布</span></span><br><span class="line"><span class="comment">#   -crlhours 下一个吊销列表将在n小时后发布</span></span><br><span class="line">openssl ca -revoke cert.pem </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看吊销列表</span></span><br><span class="line">openssl crl -<span class="keyword">in</span> testca.crl -text -noout</span><br></pre></td></tr></table></figure>



<h4 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h4><h5 id="证书请求文件参数说明"><a href="#证书请求文件参数说明" class="headerlink" title="证书请求文件参数说明"></a>证书请求文件参数说明</h5><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;C</td>
<td>Country Name (2 letter code)</td>
<td>两字母的国家代码，例如 “CN”。</td>
</tr>
<tr>
<td>&#x2F;ST</td>
<td>State or Province Name</td>
<td>州或省的全名。</td>
</tr>
<tr>
<td>&#x2F;L</td>
<td>Locality Name (e.g., city)</td>
<td>城市或地区的全名。</td>
</tr>
<tr>
<td>&#x2F;O</td>
<td>Organization Name (e.g., company)</td>
<td>公司或组织的全名。</td>
</tr>
<tr>
<td>&#x2F;OU</td>
<td>Organizational Unit Name (e.g., section)</td>
<td>部门或单位的全名。</td>
</tr>
<tr>
<td>&#x2F;CN</td>
<td>Common Name (e.g., your name or your server’s hostname)</td>
<td>通常是你的服务器的主机名。</td>
</tr>
<tr>
<td>emailAddress</td>
<td>Email Address</td>
<td>电子邮件地址，用于证书联系。</td>
</tr>
</tbody></table>
<p>这些信息将用于填写证书请求文件。在实际情况中，一些字段可能不是必需的，具体取决于你的使用场景和证书颁发机构（CA）的要求。通常，“Common Name” 是最重要的字段，应该设置为与你的服务器域名或主机名相匹配的值。其他字段的值可以根据实际情况填写。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/C=CN/ST=Tianjin/L=Tianjin/O=Example/OU=DEV/CN=example.com/emailAddress=dev@example.com</span><br></pre></td></tr></table></figure>



<h5 id="X-509扩展配置"><a href="#X-509扩展配置" class="headerlink" title="X.509扩展配置"></a>X.509扩展配置</h5><p>v3.ext</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">authorityKeyIdentifier</span>=keyid,issuer</span><br><span class="line"><span class="attr">subjectKeyIdentifier</span>=hash</span><br><span class="line"><span class="attr">basicConstraints</span>=CA:<span class="literal">FALSE</span></span><br><span class="line"><span class="attr">keyUsage</span> = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line"><span class="comment">#extendedKeyUsage = serverAuth</span></span><br><span class="line"><span class="attr">subjectAltName</span> = @alt_names</span><br><span class="line"><span class="section">[alt_names]</span></span><br><span class="line"><span class="attr">DNS.1</span>=example.io</span><br><span class="line"><span class="attr">DNS.2</span>=*.example.io</span><br><span class="line"><span class="attr">IP.3</span>=<span class="number">192.168</span>.<span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<p> extendedKeyUsage 可以指定证书目的，即用途，一般有</p>
<p>​	serverAuth 保证远程计算机的身份</p>
<p>​	clientAuth 向远程计算机证明你的身份</p>
<p>​	codeSigning 确保软件来自软件发布者，保护软件在发行后不被更改</p>
<p>​	emailProtection 保护电子邮件消息</p>
<p>​	timeStamping 允许用当前时间签名数据,如果不指定，则默认为 所有应用程序策略</p>
<p>SubjectAlternativeName</p>
<p>​	DNS.1用来确保网站的域名必须时<code>*.example.com</code>，</p>
<p>​	IP.1用来确保网站的IP地址，如果证书里面的内容和实际对应不上，浏览器就会报错。</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://developer.baidu.com/article/detail.html?id=3350912">构建安全的X.509三级证书体系：OpenSSL实战指南-百度开发者中心 (baidu.com)</a></p>
<p><a href="https://www.cnblogs.com/happy-8090/articles/11830636.html">如何创建自签名的 SSL 证书 - HappyVK - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/linziping/p/16857167.html">关于OpeSSL生成自签名证书-包含完整证书链生成（全网最全） - 52只鱼 - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Https证书</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04安装ROS-Melodic</title>
    <url>/2025/09/04/Linux/Ubuntu18.04%E5%AE%89%E8%A3%85ROS-Melodic/</url>
    <content><![CDATA[<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul>
<li><strong>操作系统</strong>: Ubuntu 18.04 (Bionic Beaver)</li>
<li><strong>ROS 版本</strong>: Melodic Morenia (官方长期支持版本)</li>
<li><strong>Python 版本</strong>: 2.7.x (ROS Melodic 默认使用)</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="1-配置软件源和密钥"><a href="#1-配置软件源和密钥" class="headerlink" title="1. 配置软件源和密钥"></a>1. 配置软件源和密钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>

<h3 id="2-更新软件包列表"><a href="#2-更新软件包列表" class="headerlink" title="2. 更新软件包列表"></a>2. 更新软件包列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-ROS-Melodic"><a href="#3-安装-ROS-Melodic" class="headerlink" title="3. 安装 ROS Melodic"></a>3. 安装 ROS Melodic</h3><p><strong>完整桌面版</strong> (推荐，包含 GUI 工具、仿真器和常用库):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>

<p><strong>其他可选版本</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ros-melodic-desktop    <span class="comment"># 基础桌面版（无仿真器）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install ros-melodic-ros-base   <span class="comment"># 最小核心版（仅通信库和工具）</span></span><br></pre></td></tr></table></figure>

<h3 id="4-初始化-rosdep"><a href="#4-初始化-rosdep" class="headerlink" title="4. 初始化 rosdep"></a>4. 初始化 rosdep</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure>

<h3 id="5-设置环境变量"><a href="#5-设置环境变量" class="headerlink" title="5. 设置环境变量"></a>5. 设置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="6-安装构建工具和依赖"><a href="#6-安装构建工具和依赖" class="headerlink" title="6. 安装构建工具和依赖"></a>6. 安装构建工具和依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure>

<h3 id="7-创建示例工作空间-可选"><a href="#7-创建示例工作空间-可选" class="headerlink" title="7. 创建示例工作空间 (可选)"></a>7. 创建示例工作空间 (可选)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>

<h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>打开新终端，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>如果看到类似以下输出，说明安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... logging to /home/username/.ros/log/xxx/roslaunch-hostname-xxx.log</span><br><span class="line">Checking log directory for disk usage. This may take a while.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking log file disk usage. Usage is &lt;1GB.</span><br><span class="line"></span><br><span class="line">started roslaunch server http://hostname:xxx/</span><br><span class="line">ros_comm version 1.14.3</span><br></pre></td></tr></table></figure>

<h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><h3 id="1-密钥获取失败"><a href="#1-密钥获取失败" class="headerlink" title="1. 密钥获取失败"></a>1. 密钥获取失败</h3><p>如果 <code>apt-key adv</code> 失败，可以手动下载并添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL <span class="string">&#x27;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&#x27;</span> | <span class="built_in">sudo</span> apt-key add -</span><br></pre></td></tr></table></figure>

<h3 id="2-网络问题"><a href="#2-网络问题" class="headerlink" title="2. 网络问题"></a>2. 网络问题</h3><p>如果下载速度慢，可以替换为国内镜像源（如清华源）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Python-版本验证"><a href="#3-Python-版本验证" class="headerlink" title="3. Python 版本验证"></a>3. Python 版本验证</h3><p>确保系统中已安装 Python 2.7：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python --version  <span class="comment"># 应显示 Python 2.7.x</span></span><br></pre></td></tr></table></figure>

<h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><p>安装完成后，可以使用以下命令测试 ROS 功能：</p>
<ul>
<li><code>roscore</code> - 启动 ROS master</li>
<li><code>rosrun roscpp_tutorials talker</code> - 运行发布者节点</li>
<li><code>rosrun roscpp_tutorials listener</code> - 运行订阅者节点</li>
</ul>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="http://wiki.ros.org/melodic">ROS Melodic 官方文档</a></li>
<li><a href="http://wiki.ros.org/ROS/Installation">ROS 安装指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ROS</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署LIO-SAM</title>
    <url>/2025/09/04/Linux/Ubuntu%E9%83%A8%E7%BD%B2LIO-SAM/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LIO-SAM (Lidar Inertial Odometry and Mapping) 是一个紧耦合的激光雷达惯性里程计框架，集成了 IMU 预积分和 GPS 数据，适用于机器人建图和定位。</p>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><table>
<thead>
<tr>
<th>组件</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ubuntu</strong></td>
<td>18.04+</td>
<td>-</td>
</tr>
<tr>
<td><strong>ROS</strong></td>
<td>Melodic</td>
<td>-</td>
</tr>
<tr>
<td><strong>gtsam</strong></td>
<td>4.0.2</td>
<td><a href="https://github.com/borglab/gtsam">GitHub</a></td>
</tr>
<tr>
<td><strong>Eigen</strong></td>
<td>3.3.7</td>
<td><a href="https://gitlab.com/libeigen/eigen/-/archive/3.3.7/eigen-3.3.7.tar.gz">GitLab</a></td>
</tr>
<tr>
<td><strong>LIO-SAM</strong></td>
<td>最新版</td>
<td><a href="https://github.com/TixiaoShan/LIO-SAM.git">GitHub</a></td>
</tr>
</tbody></table>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="1-安装系统依赖"><a href="#1-安装系统依赖" class="headerlink" title="1. 安装系统依赖"></a>1. 安装系统依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新系统包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装必要的开发工具和依赖库</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y build-essential cmake libboost-all-dev</span><br></pre></td></tr></table></figure>

<h3 id="2-安装-Eigen-库"><a href="#2-安装-Eigen-库" class="headerlink" title="2. 安装 Eigen 库"></a>2. 安装 Eigen 库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并解压 Eigen</span></span><br><span class="line">wget https://gitlab.com/libeigen/eigen/-/archive/3.3.7/eigen-3.3.7.tar.gz</span><br><span class="line">tar -zxvf eigen-3.3.7.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> eigen-3.3.7</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"><span class="built_in">sudo</span> cmake ..</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建符号链接以便系统找到 Eigen 头文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -r /usr/local/include/eigen3/Eigen/ /usr/local/include/</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-ROS-Melodic"><a href="#3-安装-ROS-Melodic" class="headerlink" title="3. 安装 ROS Melodic"></a>3. 安装 ROS Melodic</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 ROS 软件源（清华镜像）</span></span><br><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 ROS 密钥</span></span><br><span class="line"><span class="built_in">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包列表并安装 ROS</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y ros-melodic-desktop-full</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 ROS 开发工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y ros-melodic-rqt* python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 rosdep</span></span><br><span class="line"><span class="built_in">sudo</span> rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure>

<h3 id="4-配置-ROS-环境"><a href="#4-配置-ROS-环境" class="headerlink" title="4. 配置 ROS 环境"></a>4. 配置 ROS 环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 ROS 环境变量添加到 bashrc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="5-安装-gtsam"><a href="#5-安装-gtsam" class="headerlink" title="5. 安装 gtsam"></a>5. 安装 gtsam</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆 gtsam 仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/borglab/gtsam.git</span><br><span class="line"><span class="built_in">cd</span> gtsam</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 4.0.2 版本</span></span><br><span class="line">git checkout 4.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<h3 id="6-安装-LIO-SAM"><a href="#6-安装-LIO-SAM" class="headerlink" title="6. 安装 LIO-SAM"></a>6. 安装 LIO-SAM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建工作空间</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 LIO-SAM</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/TixiaoShan/LIO-SAM.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">rosdep install --from-paths src --ignore-src -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">catkin_make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作空间环境</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/catkin_ws/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><h3 id="测试-ROS-安装"><a href="#测试-ROS-安装" class="headerlink" title="测试 ROS 安装"></a>测试 ROS 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 ROS 核心</span></span><br><span class="line">roscore</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新终端中检查 ROS 环境</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="测试-LIO-SAM-编译"><a href="#测试-LIO-SAM-编译" class="headerlink" title="测试 LIO-SAM 编译"></a>测试 LIO-SAM 编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查 LIO-SAM 包是否存在</span></span><br><span class="line">rospack find lio_sam</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试运行节点（需要相应的启动文件）</span></span><br><span class="line">roslaunch lio_sam run.launch</span><br></pre></td></tr></table></figure>

<h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><h3 id="1-Eigen-头文件找不到"><a href="#1-Eigen-头文件找不到" class="headerlink" title="1. Eigen 头文件找不到"></a>1. Eigen 头文件找不到</h3><p><strong>问题</strong>：编译时出现 <code>fatal error: Eigen/Dense: No such file or directory</code></p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保 Eigen 头文件在正确位置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/local/include/eigen3/Eigen /usr/local/include/Eigen</span><br></pre></td></tr></table></figure>

<h3 id="2-gtsam-版本不兼容"><a href="#2-gtsam-版本不兼容" class="headerlink" title="2. gtsam 版本不兼容"></a>2. gtsam 版本不兼容</h3><p><strong>问题</strong>：需要特定版本的 gtsam</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保使用 gtsam 4.0.2 版本</span></span><br><span class="line"><span class="built_in">cd</span> gtsam</span><br><span class="line">git checkout 4.0.2</span><br></pre></td></tr></table></figure>

<h3 id="3-ROS-依赖问题"><a href="#3-ROS-依赖问题" class="headerlink" title="3. ROS 依赖问题"></a>3. ROS 依赖问题</h3><p><strong>问题</strong>：缺少 ROS 包依赖</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装所有缺失的依赖</span></span><br><span class="line">rosdep install --from-paths src --ignore-src -y</span><br></pre></td></tr></table></figure>

<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="启动-LIO-SAM"><a href="#启动-LIO-SAM" class="headerlink" title="启动 LIO-SAM"></a>启动 LIO-SAM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 LIO-SAM 主要节点</span></span><br><span class="line">roslaunch lio_sam run.launch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动可视化工具</span></span><br><span class="line">roslaunch lio_sam visualization.launch</span><br></pre></td></tr></table></figure>

<h3 id="数据播放"><a href="#数据播放" class="headerlink" title="数据播放"></a>数据播放</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 播放 bag 文件</span></span><br><span class="line">rosbag play your_data.bag</span><br></pre></td></tr></table></figure>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/catkin_ws/</span><br><span class="line">└── src/</span><br><span class="line">    └── LIO-SAM/</span><br><span class="line">        ├── config/          # 配置文件</span><br><span class="line">        ├── launch/          # 启动文件</span><br><span class="line">        ├── src/            # 源代码</span><br><span class="line">        └── package.xml     # ROS 包配置</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><strong>版本匹配</strong>：确保所有组件的版本兼容性</li>
<li><strong>内存要求</strong>：编译过程需要足够的内存，建议 8GB+ RAM</li>
<li><strong>网络连接</strong>：下载依赖需要稳定的网络连接</li>
<li><strong>权限问题</strong>：某些操作需要 sudo 权限</li>
</ol>
<h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><ol>
<li><strong>配置参数</strong>：根据你的传感器调整 <code>config/params.yaml</code></li>
<li><strong>数据采集</strong>：使用你的传感器采集数据</li>
<li><strong>性能调优</strong>：根据实际场景调整算法参数</li>
</ol>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="https://github.com/TixiaoShan/LIO-SAM">LIO-SAM 官方文档</a></li>
<li><a href="http://wiki.ros.org/melodic/Installation/Ubuntu">ROS Melodic 安装指南</a></li>
<li><a href="https://gtsam.org/">gtsam 文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>机器人</tag>
        <tag>LIO-SAM</tag>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署ROS</title>
    <url>/2025/08/29/Linux/Ubuntu%E9%83%A8%E7%BD%B2ROS/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>建议准备一个干净、换好源的 <strong>Ubuntu 16.04</strong> 及以上版本（建议 <a href="https://mirrors-i.tuna.tsinghua.edu.cn/help/ubuntu/">清华源</a> ），本教程也适用其他 ROS1版本。</p>
<p>查看ubuntu 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>
<p>根据自己的 Ubuntu 的版本选择 ROS 版本 (示例是 <strong>Ubuntu 18.04</strong> 所以对应ROS版本为 <strong>melodic</strong>）<br>![[Ubuntu部署ROS&#x2F;IMG-20250829234441526.png]]</p>
<h2 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h2><h4 id="1-安装源"><a href="#1-安装源" class="headerlink" title="1. 安装源"></a>1. 安装源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-设置密钥"><a href="#2-设置密钥" class="headerlink" title="2. 设置密钥"></a>2. 设置密钥</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ros-melodic-desktop</span><br><span class="line"><span class="comment"># 其他版本替换对应的版本（例如 noetic ）</span></span><br><span class="line"><span class="comment"># sudo apt install ros-noetic-desktop</span></span><br></pre></td></tr></table></figure>

<h4 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment">#使环境生效</span></span><br><span class="line"><span class="comment"># 替换对应版本同上</span></span><br><span class="line"><span class="comment"># echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span></span><br></pre></td></tr></table></figure>

<h4 id="5-配置rosdep"><a href="#5-配置rosdep" class="headerlink" title="5. 配置rosdep"></a>5. 配置rosdep</h4><p>在使用许多 ROS 工具之前，需要初始化 <code>rosdep</code>，有些功能包源码编译需要<code>rosdep</code> 来安装这些系统依赖项，不配置也不影响ros使用，所以后面需要时再来配置也可以。 rosdep 请求的文件都放在 github 上的, 推荐使用代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br><span class="line"><span class="comment"># 对于Ubuntu20</span></span><br><span class="line"><span class="comment"># sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="built_in">sudo</span> rosdep init</span><br><span class="line">rosdep update</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>

<p>参考<br><a href="https://wiki.ros.org/melodic/Installation/Ubuntu">官方文档(melodic)</a><br><a href="https://blog.csdn.net/qq_41450811/article/details/99079041">ubuntu18.04安装ROS Melodic（最详细配置）-CSDN博客</a><br><a href="https://blog.csdn.net/qq_43310597/article/details/105756819?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242">基于Ubuntu18.04的ROS Melodic环境详细配置（含各种大坑及填坑）</a><br><a href="https://blog.csdn.net/maizousidemao/article/details/119846292">[ROS 系列学习教程] ROS与操作系统版本对应关系_ros版本-CSDN博客</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ROS</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>FRP配置</title>
    <url>/2023/07/07/%E6%9D%82%E9%A1%B9/FRP%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># TCP通信端口</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#UDP通信端口</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仪表板界面配置</span></span><br><span class="line"><span class="attr">dashboard_port</span>=<span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span>=admin</span><br><span class="line"><span class="attr">dashboard_pwd</span>=admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许使用的端口号,可以指定范围也可以用‘，’分割</span></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">18081</span>-<span class="number">18090</span>,<span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端开机自启配置"><a href="#服务端开机自启配置" class="headerlink" title="服务端开机自启配置"></a>服务端开机自启配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/systemd/system/frps.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> frps.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl start frps.service</span><br></pre></td></tr></table></figure>

<p>启动文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span> = Frp Server Service</span><br><span class="line"><span class="attr">After</span> = network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span> = simple</span><br><span class="line"><span class="attr">User</span> = nobody</span><br><span class="line"><span class="attr">Restart</span> = <span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span> = <span class="number">5</span>s</span><br><span class="line"><span class="attr">ExecStart</span> = /usr/local/bin/frps -c /usr/local/etc/frp/frps.ini</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span> = multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment">#替换IP地址为服务端IP</span></span><br><span class="line"><span class="attr">server_addr</span>=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">server_port</span>=<span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows远程桌面</span></span><br><span class="line"><span class="section">[rdp]</span></span><br><span class="line"><span class="attr">type</span>=tcp</span><br><span class="line"><span class="comment"># 映射IP</span></span><br><span class="line"><span class="attr">local_ip</span>=<span class="number">127.0</span>.<span class="number">0.1</span> </span><br><span class="line"><span class="comment"># 映射端口（本地）</span></span><br><span class="line"><span class="attr">local_port</span>=<span class="number">3389</span></span><br><span class="line"><span class="comment"># 远程端口（服务器）注意端口要在允许端口内切未被占用</span></span><br><span class="line"><span class="attr">remote_port</span>=<span class="number">18087</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg mp3转pcm</title>
    <url>/2022/06/24/%E6%9D%82%E9%A1%B9/ffmpeg-mp3%E8%BD%ACpcm/</url>
    <content><![CDATA[<p>大端数据格式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ffmpeg</span> <span class="string">-i</span> <span class="string">test.mp3</span> <span class="string">-f</span> <span class="string">s16be</span> <span class="string">-ar</span> <span class="number">16000</span> <span class="string">-ac</span> <span class="number">1</span> <span class="string">-acodec</span> <span class="string">pcm_s16be</span> <span class="string">pcm16k.pcm</span></span><br></pre></td></tr></table></figure>

<p>小端数据格式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ffmpeg</span> <span class="string">-i</span> <span class="string">test.mp3</span> <span class="string">-f</span> <span class="string">s16le</span> <span class="string">-ar</span> <span class="number">16000</span> <span class="string">-ac</span> <span class="number">1</span> <span class="string">-acodec</span> <span class="string">pcm_s16le</span> <span class="string">pcm16k.pcm</span></span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li>-acodec pcm_s16be：输出pcm格式，采用signed 16编码，字节序为大尾端（小尾端为le)；</li>
<li>-ar 16000: 采样率为16000</li>
<li>-ac 1: 声道数为1</li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>FFmp</tag>
      </tags>
  </entry>
  <entry>
    <title>公司常见后缀的含义</title>
    <url>/2025/05/30/%E6%9D%82%E9%A1%B9/%E5%85%AC%E5%8F%B8%E5%B8%B8%E8%A7%81%E5%90%8E%E7%BC%80%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h3 id="1-Co-Ltd"><a href="#1-Co-Ltd" class="headerlink" title="1. Co., Ltd."></a>1. Co., Ltd.</h3><ul>
<li>全称：Company Limited</li>
<li>含义：有限责任公司，常见于英国、中国及亚洲地区</li>
<li>特点：”Co.“为Company缩写，”.“表示缩写符号，”,”用于分隔前后词</li>
</ul>
<h3 id="2-Inc"><a href="#2-Inc" class="headerlink" title="2. Inc."></a>2. Inc.</h3><ul>
<li>全称：Incorporated</li>
<li>含义：股份有限公司，多用于美国、加拿大</li>
<li>示例：Apple Inc.，强调股东责任限于股份投资</li>
</ul>
<h3 id="3-LLC"><a href="#3-LLC" class="headerlink" title="3. LLC"></a>3. LLC</h3><ul>
<li>全称：Limited Liability Company</li>
<li>含义：有限责任公司（美国特有形式）</li>
<li>特点：兼具合伙制灵活性与股份制有限责任，如Google LLC</li>
</ul>
<h3 id="4-GmbH"><a href="#4-GmbH" class="headerlink" title="4. GmbH"></a>4. GmbH</h3><ul>
<li>全称：Gesellschaft mit beschränkter Haftung</li>
<li>含义：有限责任公司，德国及德语区专用</li>
<li>示例：Bosch GmbH1</li>
</ul>
<h3 id="5-AG"><a href="#5-AG" class="headerlink" title="5. AG"></a>5. AG</h3><ul>
<li>全称：Aktiengesellschaft</li>
<li>含义：股份有限公司，德国及瑞士常见</li>
<li>示例：BMW AG</li>
</ul>
<h3 id="6-S-A"><a href="#6-S-A" class="headerlink" title="6. S.A."></a>6. S.A.</h3><pre><code>- 全称：Société Anonyme（法）/Sociedad Anónima（西）
- 含义：股份有限公司，流行于法国、西班牙等拉丁语系国家
- 示例：L’Oréal S.A.1
</code></pre>
<h3 id="7-Plc"><a href="#7-Plc" class="headerlink" title="7. Plc"></a>7. Plc</h3><ul>
<li>全称：Public Limited Company</li>
<li>含义：公众有限公司（英国上市企业专用）</li>
<li>示例：HSBC Holdings plc1</li>
</ul>
<h3 id="8-株式会社（Kabushiki-Kaisha）"><a href="#8-株式会社（Kabushiki-Kaisha）" class="headerlink" title="8. 株式会社（Kabushiki Kaisha）"></a>8. 株式会社（Kabushiki Kaisha）</h3><ul>
<li>缩写：KK</li>
<li>含义：日本股份有限公司</li>
<li>示例：Toyota Motor Corporation KK</li>
</ul>
<p><strong>地域差异提示</strong>：</p>
<ul>
<li>英国”Ltd.”与美国”LLC”虽均表有限责任，但法律结构不同</li>
<li>荷兰用”BV”（私人有限公司），意大利用”S.p.A.”（股份公司）</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>在CMD命令行中切换到管理员权限模式</title>
    <url>/2018/06/10/%E6%9D%82%E9%A1%B9/%E5%9C%A8CMD%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%88%87%E6%8D%A2%E5%88%B0%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>方式1：</p>
<p>搜索CMD Ctrl+Shift+Enter</p>
<p>方式2：</p>
<p>打开CMD，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runas /noprofile /user:Administrator cmd</span><br></pre></td></tr></table></figure>

<p>输入Administrator账户的密码</p>
<blockquote>
<p>runas 允许用户用其他权限运行指定的工具和程序</p>
<p>&#x2F;noprofile 指定不加载用户的配置文件</p>
<p>&#x2F;user:UserAccountName 指定在其下运行程序的账户</p>
</blockquote>
<p>常见问题</p>
<p>运行runas 指令输入密码报错“无法启动服务，原因可能是已被禁用或与其关联的设备没有启动。”</p>
<p>这是因为“Secondary Logo”服务没有启动，这个服务是”在不同凭据下启用启动过程“。直接在cmd中输入services.msc,将服务从禁用改为手动就好了，之后再次输入runas命令就可以使用administrator账户运行。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>物联网国标</title>
    <url>/2022/11/01/%E6%9D%82%E9%A1%B9/%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BD%E6%A0%87/</url>
    <content><![CDATA[<p>GB&#x2F;T 35134-2017  物联网智能家居 设备描述方法</p>
<p>GB&#x2F;T 35143-2017  物联网智能家居 数据和设备编码</p>
<p>GB&#x2F;T 35317-2017 公安物联网系统信息安全等级保护要求</p>
<p>GB&#x2F;T 35318-2017 公安物联网感知终端安全防护技术要求</p>
<p>GB&#x2F;T 35319-2017  物联网 系统接口要求</p>
<p>GB&#x2F;T 35419-2017  物联网标识体系 Ecode在一维条码中的存储</p>
<p>GB&#x2F;T 35420-2017  物联网标识体系 Ecode在二维码中的存储</p>
<p>GB&#x2F;T 35421-2017  物联网标识体系 Ecode在射频标签中的存储</p>
<p>GB&#x2F;T 35422-2017  物联网标识体系 Ecode的注册与管理</p>
<p>GB&#x2F;T 35423-2017  物联网标识体系 Ecode在NFC标签中的存储</p>
<p>GB&#x2F;T 35592-2017  公安物联网感知终端接入安全技术要求</p>
<p>GB&#x2F;T 35136-2017  智能家居自动控制设备通用技术要求</p>
<p>GB&#x2F;T 35255-2017  LED公共照明智能系统接口应用层通信协议</p>
<p>GB&#x2F;T 35291-2017  信息安全技术 智能密码钥匙应用接口规范</p>
<p>GB&#x2F;T 30269.502-2017  信息技术 传感器网络 第502部分：标识：传感节点标识符解析</p>
<p>GB&#x2F;T 30269.602-2017  信息技术 传感器网络 第602部分：信息安全：低速率无线传感器网络网络层和应用支持子层安全规范</p>
<p>GB&#x2F;T 30269.801-2017  信息技术 传感器网络 第801部分：测试：通用要求</p>
<p>GB&#x2F;T 30269.803-2017  信息技术 传感器网络 第803部分：测试：低速无线传感器网络网络层和应用支持子层</p>
<p>GB&#x2F;T 35129-2017  面向食品制造业的射频识别系统 环境适应性要求</p>
<p>GB&#x2F;T 35130-2017  面向食品制造业的射频识别系统 射频标签信息与编码规范</p>
<p>GB&#x2F;T 35135-2017  面向食品制造业的射频识别系统 应用要求</p>
<p>GB&#x2F;T 17626.6-2017  电磁兼容 试验和测量技术 射频场感应的传导骚扰抗扰度</p>
<p>GB&#x2F;T 35290-2017  信息安全技术 射频识别（RFID）系统通用安全技术要求</p>
<p>GB&#x2F;T 35120-2017  制造过程物联的数字化模型信息交换规范</p>
<p>GB&#x2F;T 35122-2017  制造过程物联的数字化模型信息表达规范</p>
<p>GB&#x2F;T 35128-2017  集团企业经营管理信息化核心构件</p>
<p>GB&#x2F;T 34966.1-2017  卫星导航增强信息互联网传输 第1部分：播发体制</p>
<p>GB&#x2F;T 34966.2-2017  卫星导航增强信息互联网传输 第2部分：接口要求</p>
<p>GB&#x2F;T 34966.3-2017  卫星导航增强信息互联网传输 第3部分：数据传输格式</p>
<p>GB&#x2F;T 35403.1-2017  国家物品编码与基础信息通用规范 第1部分：总体框架</p>
<p>GB&#x2F;T 35589-2017  信息技术 大数据 技术参考模型</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>国标</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SuperMicro主板风扇转速过低告警</title>
    <url>/2023/07/10/%E6%9D%82%E9%A1%B9/%E8%A7%A3%E5%86%B3SuperMicro%E4%B8%BB%E6%9D%BF%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F%E8%BF%87%E4%BD%8E%E5%91%8A%E8%AD%A6/</url>
    <content><![CDATA[<h1 id="解决SuperMicro主板风扇转速过低告警"><a href="#解决SuperMicro主板风扇转速过低告警" class="headerlink" title="解决SuperMicro主板风扇转速过低告警"></a>解决SuperMicro主板风扇转速过低告警</h1><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p> 系统启动后风扇忽高忽低，进入IPMI后台可以看到，看到传感器日志里大量的告警</p>
 <img src="/2023/07/10/%E6%9D%82%E9%A1%B9/%E8%A7%A3%E5%86%B3SuperMicro%E4%B8%BB%E6%9D%BF%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F%E8%BF%87%E4%BD%8E%E5%91%8A%E8%AD%A6/IMG-20250804110128732.png" class="" title="告警">

<p> 造成此问题的原因是风扇转速过低，触发了超微的风扇转速允许的下限，从而强制满速运转，而在满速后主板又很快发现没有问题，且此时温度较低，风扇开始降速，直到降速到下限以下，重复此过程。</p>
<p>在进入IPMI后台管理界面后风扇速度有四种智能模式可调</p>
<ul>
<li><p>Standard: zone0和zone1 风速为50%</p>
</li>
<li><p>Optimal: 风速为30%</p>
</li>
<li><p>Full: 风速为100%</p>
</li>
<li><p>Heavy IO: zone0 为50%，zone1 为75%</p>
</li>
</ul>
<img src="/2023/07/10/%E6%9D%82%E9%A1%B9/%E8%A7%A3%E5%86%B3SuperMicro%E4%B8%BB%E6%9D%BF%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F%E8%BF%87%E4%BD%8E%E5%91%8A%E8%AD%A6/IMG-20250804110128774.png" class="">



<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="1-在服务器上安装IPMItool"><a href="#1-在服务器上安装IPMItool" class="headerlink" title="1. 在服务器上安装IPMItool"></a>1. 在服务器上安装IPMItool</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ipmitool <span class="comment"># Ubuntu/Debian指令</span></span><br><span class="line">yum install ipmitool <span class="comment"># CentOS指令</span></span><br></pre></td></tr></table></figure>



<h4 id="2-设置风扇转速"><a href="#2-设置风扇转速" class="headerlink" title="2. 设置风扇转速"></a>2. 设置风扇转速</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 风扇名可以看告警里边的对应风扇名</span></span><br><span class="line">ipmitool sensor thresh FAN1 lower 100 125 125</span><br><span class="line">ipmitool sensor thresh FANA lower 100 125 125</span><br></pre></td></tr></table></figure>

<h4 id="3-Windows-下远程操作IPMI"><a href="#3-Windows-下远程操作IPMI" class="headerlink" title="3. Windows 下远程操作IPMI"></a>3. Windows 下远程操作IPMI</h4><p>ipmitool windows 版 <a href="http://www.4008600011.com/wp-content/uploads/2019/08/IPMIToolWin.zip">下载地址</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipmitool -H [IPMI网口IP地址] -U [IMPI账户] -P [IPMI密码] sensor thresh FAN1 lower 100 125 125</span><br><span class="line">ipmitool -H [IPMI网口IP地址] -U [IMPI账户] -P [IPMI密码] sensor thresh FANA lower 100 125 125</span><br></pre></td></tr></table></figure>



<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果你运行上面的命令后，风扇转速回落后马上又返回原样，这表明服务器的自动调速覆盖了你手动设置的转速。你需要切换服务器风扇策略为全速（Full Speed），在这个策略下服务器不会使用自动调节转速，因此也不会覆盖你手动设置的转速。</p>
<p>运行下面的命令切换到全速模式（也可以进入IPMI界面调整）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipmitool -H [IPMI网口IP地址] -U [IMPI账户] -P [IPMI密码] 0x30 0x45 0x01 0x01</span><br><span class="line"><span class="comment"># 最后一个0x01表示全速模式。如果为0x00则表示标准（Standard）；0x02表示最优（Optimal）</span></span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/read/cv22752140/">1.解决超微 SuperMicro 主板风扇反复高低转速问题 - 哔哩哔哩 (bilibili.com)</a></p>
<p><a href="https://www.licc.tech/article?id=33">超微服务器Supermicro X9&#x2F;X10&#x2F;X11设置风扇转速 - 辰宸的备忘录 (licc.tech)</a></p>
<p><a href="https://blog.csdn.net/owlcity123/article/details/106620113">ipmitool常用命令详解_ipmitool lan set_owlcity123的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>超微</tag>
        <tag>SuperMicro</tag>
        <tag>转速过低告警</tag>
      </tags>
  </entry>
  <entry>
    <title>阵列卡接口型号</title>
    <url>/2024/09/23/%E6%9D%82%E9%A1%B9/%E9%98%B5%E5%88%97%E5%8D%A1%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="接口型号"><a href="#接口型号" class="headerlink" title="接口型号"></a>接口型号</h4><p><a href="https://blog.csdn.net/dany_zj_cn/article/details/112966388">SFF SAS接口_8087接口-CSDN博客</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>阵列卡</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>GoLang学习笔记</title>
    <url>/2025/03/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记-1</title>
    <url>/2025/03/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-1</title>
    <url>/2025/03/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Qt/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>8种主要排序算法的CSharp实现</title>
    <url>/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="8种主要排序算法的C-实现"><a href="#8种主要排序算法的C-实现" class="headerlink" title="8种主要排序算法的C#实现"></a>8种主要排序算法的C#实现</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>8种主要排序算法的实现及优化，包含选择排序，冒泡排序，插入排序，快速排序，归并排序，堆排序，希尔排序，基数排序。文末实际测试并比较。</p>
</blockquote>
<hr>
<p>新的一年到了，很多园友都辞职要去追求更好的工作环境，我也是其中一个，呵呵！</p>
<p>最近闲暇的时候我开始重温一些常用的算法。老早就买了《算法导论》，一直都没啃下去。</p>
<p>这本书确实很好，只是太难读了，总是读了几章就又读不下去了！工作上也几乎用不到。</p>
<p>我这段时间发现看这些排序算法比以前容易了很多，就借此机会将它们整理总结起来。</p>
<p>一是方便以后重温，二是可以应对笔试面试。同时也希望这篇博文可以帮助各位刚辞职和正在学习排序算法的园友。</p>
<p>PS：有可能实现的代码并不是最优的，如果有什么错误或者值得改进的地方，还请大家帮忙指出。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>排序算法是我们编程中遇到的最多的算法。目前主流的算法有8种。</p>
<p>  平均时间复杂度从高到低依次是：</p>
<p>     冒泡排序（o(n<sup>2</sup>)），选择排序（o(n<sup>2</sup>)），插入排序（o(n<sup>2</sup>)），堆排序（o(nlogn)），</p>
<p>     归并排序（o(nlogn)），快速排序（o(nlogn)）， 希尔排序（o(n<sup>1.25</sup>)），基数排序（o(n)）</p>
<p>这些平均时间复杂度是参照维基百科<a href="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F">排序算法</a>罗列的。</p>
<p>是计算的理论平均值，并不意味着你的代码实现能达到这样的程度。</p>
<p>例如希尔排序，时间复杂度是由选择的步长决定的。基数排序时间复杂度最小，</p>
<p>但我实现的基数排序的速度并不是最快的，后面的结果测试图可以看到。</p>
<p><a href="http://www.cnblogs.com/fatbird/p/SortAlgorithm.html">本文</a>代码实现使用的数据源类型为IList<int>，这样可以兼容int[]和List<int>(虽然int[]有ToList()，</p>
<p>List<int>有ToArray()，哈哈！)。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是我觉得最简单暴力的排序方式了。</p>
<p>以前刚接触排序算法的时候，感觉算法太多搞不清，唯独记得选择排序的做法及实现。</p>
<p>原理：找出参与排序的数组最大值，放到末尾（或找到最小值放到开头） <a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">维基入口</a></p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SelectSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.Count - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; min =&lt;span&gt; i;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i + &lt;span&gt;1&lt;/span&gt;; j &amp;lt; data.Count; j++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[j] &amp;lt;&lt;span&gt; temp)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         min =&lt;span&gt; j;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         temp =&lt;span&gt; data[j];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (min !=&lt;span&gt; i)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    Swap(data, min, i);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：将剩余数组的最小数交换到开头。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是笔试面试经常考的内容，虽然它是这些算法里排序速度最慢的（汗），后面有测试为证。</p>
<p>原理：从头开始，每一个元素和它的下一个元素比较，如果它大，就将它与比较的元素交换，否则不动。</p>
<p>这意味着，大的元素总是在向后慢慢移动直到遇到比它更大的元素。所以每一轮交换完成都能将最大值</p>
<p>冒到最后。  <a href="http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#.E5.8A.A9.E8.AE.B0.E7.A0.81">维基入口</a></p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BubbleSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = data.Count - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; i; j++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[j] &amp;gt; data[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                         Swap(data, j, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：中需要注意的是j&lt;i，每轮冒完泡必然会将最大值排到数组末尾，所以需要排序的数应该是在减少的。</p>
<p>很多网上版本每轮冒完泡后依然还是将所有的数进行第二轮冒泡即j&lt;data.Count-1，这样会增加比较次数。</p>
<h4 id="通过标识提升冒泡排序"><a href="#通过标识提升冒泡排序" class="headerlink" title="通过标识提升冒泡排序"></a>通过标识提升冒泡排序</h4><p>在维基上看到，可以通过添加标识来分辨剩余的数是否已经有序来减少比较次数。感觉很有意思，可以试试。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BubbleSortImprovedWithFlag(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; flag;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = data.Count - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; i; j++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[j] &amp;gt; data[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         Swap(data, j, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (flag) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：发现某轮冒泡没有任何数进行交换（即已经有序），就跳出排序。</p>
<p>我起初也以为这个方法是应该有不错效果的，可是实际测试结果并不如想的那样。和未优化耗费时间一样（对于随机数列）。</p>
<p>由果推因，那么应该是冒泡排序对于随机数列，当剩余数列有序的时候，也没几个数要排列了！？</p>
<p>不过如果已经是有序数列或者部分有序的话，这个冒泡方法将会提升很大速度。</p>
<h3 id="鸡尾酒排序（来回排序）"><a href="#鸡尾酒排序（来回排序）" class="headerlink" title="鸡尾酒排序（来回排序）"></a>鸡尾酒排序（来回排序）</h3><h4 id="对冒泡排序进行更大的优化"><a href="#对冒泡排序进行更大的优化" class="headerlink" title="对冒泡排序进行更大的优化"></a>对冒泡排序进行更大的优化</h4><p>冒泡排序只是单向冒泡，而鸡尾酒来回反复双向冒泡。</p>
<p>原理：自左向右将大数冒到末尾，然后将剩余数列再自右向左将小数冒到开头，如此循环往复。<a href="http://zh.wikipedia.org/wiki/%E5%BE%80%E8%BF%94%E6%8E%92%E5%BA%8F">维基入口</a></p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BubbleCocktailSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; flag;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;0&lt;/span&gt;, n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = data.Count - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (i % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = n; j &amp;lt; data.Count - &lt;span&gt;1&lt;/span&gt; - m; j++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (data[j] &amp;gt; data[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                             Swap(data, j, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                             flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (flag) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     m++&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = data.Count - &lt;span&gt;1&lt;/span&gt; - m; k &amp;gt; n; k--&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (data[k] &amp;lt; data[k - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             Swap(data, k, k - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (flag) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     n++&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：分析第i轮冒泡，i是偶数则将剩余数列最大值向右冒泡至末尾，是奇数则将剩余数列最小值</p>
<p>向左冒泡至开头。对于剩余数列，n为始，data.Count-1-m为末。</p>
<p>来回冒泡比单向冒泡：对于随机数列，更容易得到有序的剩余数列。因此这里使用标识将会提升的更加明显。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种对于有序数列高效的排序。非常聪明的排序。只是对于随机数列，效率一般，交换的频率高。</p>
<p>原理：通过构建有序数列，将未排序的数从后向前比较，找到合适位置并插入。<a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">维基入口</a></p>
<p>第一个数当作有序数列。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InsertSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; data.Count; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 temp =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - &lt;span&gt;1&lt;/span&gt;; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; j--&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[j] &amp;gt;&lt;span&gt; temp)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         data[j + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; data[j];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (j == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                             data[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         data[j + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：将要排序的数（索引为i）存储起来，向前查找合适位置j+1，将i-1到j+1的元素依次向后</p>
<p>移动一位，空出j+1，然后将之前存储的值放在这个位置。</p>
<p>这个方法写的不如维基上的简洁清晰，由于合适位置是j+1所以多出了对j&#x3D;&#x3D;0的判断，但实际效率影响无差别。</p>
<p>建议比照维基和我写的排序，自行选择。</p>
<h4 id="二分查找法优化插入排序"><a href="#二分查找法优化插入排序" class="headerlink" title="二分查找法优化插入排序"></a>二分查找法优化插入排序</h4><p>插入排序主要工作是在有序的数列中对要排序的数查找合适的位置，而查找里面经典的二分查找法正可以适用。</p>
<p>原理：通过二分查找法的方式找到一个位置索引。当要排序的数插入这个位置时，大于前一个数，小于后一个数。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InsertSortImprovedWithBinarySearch(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tempIndex;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; data.Count; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 temp =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 tempIndex = BinarySearchForInsertSort(data, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, i, i);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - &lt;span&gt;1&lt;/span&gt;; j &amp;gt;= tempIndex; j--&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     data[j + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; data[j];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 data[tempIndex] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; </span><br><span class="line">&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BinarySearchForInsertSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; high, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (low &amp;gt;= data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (high &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; mid = (low + high) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (mid == key) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (data[key] &amp;gt;&lt;span&gt; data[mid])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[key] &amp;lt; data[mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; BinarySearchForInsertSort(data, mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high, key);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;else  &lt;span&gt;// data[key] &amp;lt;= data[mid]&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (mid - &lt;span&gt;1&lt;/span&gt; &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[key] &amp;gt; data[mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; BinarySearchForInsertSort(data, low, mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, key);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p> 过程解析：需要注意的是二分查找方法实现中high-low&#x3D;&#x3D;1的时候mid&#x3D;&#x3D;low，所以需要33行</p>
<p>mid-1&lt;0即mid&#x3D;&#x3D;0的判断，否则下行会索引越界。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种有效比较较多的高效排序。它包含了“分而治之”以及“哨兵”的思想。</p>
<p>原理：从数列中挑选一个数作为“哨兵”，使比它小的放在它的左侧，比它大的放在它的右侧。将要排序是数列递归地分割到</p>
<p>最小数列，每次都让分割出的数列符合“哨兵”的规则，自然就将数列变得有序。 <a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#.E5.8E.9F.E5.9C.B0.28in-place.29.E5.88.86.E5.89.B2.E7.9A.84.E7.89.88.E6.9C.AC">维基入口</a></p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QuickSortStrict(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             QuickSortStrict(data, &lt;span&gt;0&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; </span><br><span class="line">&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QuickSortStrict(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (low &amp;gt;= high) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; data[low];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i = low + &lt;span&gt;1&lt;/span&gt;, j =&lt;span&gt; high;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (data[j] &amp;gt; temp) j--&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (data[i] &amp;lt; temp &amp;amp;&amp;amp; i &amp;lt; j) i++&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= j) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                Swap(data, i, j);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 i++; j--&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (j !=&lt;span&gt; low)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                Swap(data, low, j);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             QuickSortStrict(data, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             QuickSortStrict(data, low, j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：取的哨兵是数列的第一个值，然后从第二个和末尾同时查找，左侧要显示的是小于哨兵的值，</p>
<p>所以要找到不小于的i，右侧要显示的是大于哨兵的值，所以要找到不大于的j。将找到的i和j的数交换，</p>
<p>这样可以减少交换次数。i&gt;&#x3D;j时，数列全部查找了一遍，而不符合条件j必然是在小的那一边，而哨兵</p>
<p>是第一个数，位置本应是小于自己的数。所以将哨兵与j交换，使符合“哨兵”的规则。</p>
<p>这个版本的缺点在于如果是有序数列排序的话，递归次数会很可怕的。</p>
<h4 id="另一个版本"><a href="#另一个版本" class="headerlink" title="另一个版本"></a>另一个版本</h4><p>这是维基上的一个C#版本，我觉得很有意思。这个版本并没有严格符合“哨兵”的规则。但却将“分而治之”</p>
<p>以及“哨兵”思想融入其中，代码简洁。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QuickSortRelax(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             QuickSortRelax(data, &lt;span&gt;0&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; </span><br><span class="line">&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QuickSortRelax(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (low &amp;gt;= high) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp = data[(low + high) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i = low - &lt;span&gt;1&lt;/span&gt;, j = high + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (data[++i] &amp;lt;&lt;span&gt; temp) ;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (data[--j] &amp;gt;&lt;span&gt; temp) ;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= j) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                Swap(data, i, j);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             QuickSortRelax(data, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             QuickSortRelax(data, low, i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：取的哨兵是数列中间的数。将数列分成两波，左侧小于等于哨兵，右侧大于等于哨兵。</p>
<p>也就是说，哨兵不一定处于两波数的中间。虽然哨兵不在中间，但不妨碍“哨兵”的思想的实现。所以</p>
<p>这个实现也可以达到快速排序的效果。但却造成了每次递归完成，要排序的数列数总和没有减少（除非i&#x3D;&#x3D;j）。</p>
<h4 id="针对这个版本的缺点，我进行了优化"><a href="#针对这个版本的缺点，我进行了优化" class="headerlink" title="针对这个版本的缺点，我进行了优化"></a>针对这个版本的缺点，我进行了优化</h4><p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QuickSortRelaxImproved(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             QuickSortRelaxImproved(data, &lt;span&gt;0&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; </span><br><span class="line">&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QuickSortRelaxImproved(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (low &amp;gt;= high) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp = data[(low + high) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i = low - &lt;span&gt;1&lt;/span&gt;, j = high + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; index = (low + high) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (data[++i] &amp;lt;&lt;span&gt; temp) ;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (data[--j] &amp;gt;&lt;span&gt; temp) ;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= j) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                Swap(data, i, j);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (i == index) index =&lt;span&gt; j;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (j == index) index =&lt;span&gt; i;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (j ==&lt;span&gt; i)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 QuickSortRelaxImproved(data, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 QuickSortRelaxImproved(data, low, i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i-j==1&lt;/span&gt;</span><br><span class="line">&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span&gt; i)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (index !=&lt;span&gt; i)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                        Swap(data, index, i);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     QuickSortRelaxImproved(data, i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     QuickSortRelaxImproved(data, low, i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;else &lt;span&gt;//&lt;/span&gt;&lt;span&gt;index &amp;lt; i&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (index !=&lt;span&gt; j)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        Swap(data, index, j);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     QuickSortRelaxImproved(data, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     QuickSortRelaxImproved(data, low, j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：定义了一个变量Index，来跟踪哨兵的位置。发现哨兵最后在小于自己的那堆，</p>
<p>那就与j交换，否则与i交换。达到每次递归都能减少要排序的数列数总和的目的。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序也是采用“分而治之”的方式。刚发现<a href="http://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>是一种算法范式，我还一直以为是一种需要意会的思想呢。</p>
<p>不好意思了，孤陋寡闻了，哈哈！</p>
<p>原理：将两个有序的数列，通过比较，合并为一个有序数列。 <a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">维基入口</a></p>
<p>为方便理解，此处实现用了List<int>的一些方法，随后有IList<int>版本。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; MergeSortOnlyList(List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (low ==&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; &#123; data[low] &#125;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; mergeData = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; mid = (low + high) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; leftData =&lt;span&gt; MergeSortOnlyList(data, low, mid);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; rightData = MergeSortOnlyList(data, mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (leftData[i] &amp;lt;&lt;span&gt; rightData[j])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    mergeData.Add(leftData[i]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (++i ==&lt;span&gt; leftData.Count)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         mergeData.AddRange(rightData.GetRange(j, rightData.Count -&lt;span&gt; j));</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    mergeData.Add(rightData[j]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (++j ==&lt;span&gt; rightData.Count)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         mergeData.AddRange(leftData.GetRange(i, leftData.Count -&lt;span&gt; i));</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mergeData;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; </span><br><span class="line">&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; MergeSortOnlyList(List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             data = MergeSortOnlyList(data, &lt;span&gt;0&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  &lt;span&gt;//不会改变外部引用 参照&lt;a href=&quot;http://www.cnblogs.com/fatbird/p/parametersInCsharp.html&quot; target=&quot;_blank&quot;&gt;C#参数传递</span><br><span class="line">&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：将数列分为两部分，分别得到两部分数列的有序版本，然后逐个比较，将比较出的小数逐个放进</p>
<p>新的空数列中。当一个数列放完后，将另一个数列剩余数全部放进去。</p>
<h4 id="IList版本"><a href="#IList版本" class="headerlink" title="IList版本"></a>IList<int>版本</h4><p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; MergeSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             data = MergeSort(data, &lt;span&gt;0&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; </span><br><span class="line">&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; MergeSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; length = high - low + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; mergeData =&lt;span&gt; NewInstance(data, length);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (low ==&lt;span&gt; high)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 mergeData[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; data[low];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mergeData;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; mid = (low + high) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; leftData =&lt;span&gt; MergeSort(data, low, mid);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; rightData = MergeSort(data, mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, high);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (leftData[i] &amp;lt;&lt;span&gt; rightData[j])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     mergeData[i + j] = leftData[i++]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能使用Add,Array Length不可变&lt;/span&gt;</span><br><span class="line">&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; leftData.Count)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;int&lt;/span&gt; rightLeft = rightData.Count -&lt;span&gt; j;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;0&lt;/span&gt;; m &amp;lt; rightLeft; m++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                             mergeData[i + j] = rightData[j++&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     mergeData[i + j] = rightData[j++&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (j ==&lt;span&gt; rightData.Count)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &lt;span&gt;int&lt;/span&gt; leftleft = leftData.Count -&lt;span&gt; i;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;; n &amp;lt; leftleft; n++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                             mergeData[i + j] = leftData[i++&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mergeData;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; </span><br><span class="line">&lt;span&gt;51&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程原理与上个一样，此处就不赘述了。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是根据堆这种数据结构设计的一种算法。堆的特性：父节点的值总是小于（或大于）它的子节点。近似二叉树。</p>
<p>原理：将数列构建为最大堆数列（即父节点总是最大值），将最大值（即根节点）交换到数列末尾。这样要排序的数列数总和减少，</p>
<p>同时根节点不再是最大值，调整最大堆数列。如此重复，最后得到有序数列。 <a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">维基入口</a>   <a href="http://www.cs.usfca.edu/~galles/visualization/HeapSort.html">有趣的演示</a></p>
<p>实现准备：如何将数列构造为堆——父节点i的左子节点为2i+1，右子节点为2i+2。节点i的父节点为floor((i-1)&#x2F;2)。</p>
<p>实现如下（这个实现判断和临时变量使用太多，导致效率低，评论中@小城故事提出了更好的实现）：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HeapSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            BuildMaxHeapify(data);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; data.Count;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;&lt;span&gt; j; )</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Swap(data, i, --&lt;span&gt;j);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (j - &lt;span&gt;2&lt;/span&gt; &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  &lt;span&gt;//只剩下1个数 j代表余下要排列的数的个数</span><br><span class="line">&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (k &amp;gt; (j - &lt;span&gt;2&lt;/span&gt;) / &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  &lt;span&gt;//即：k &amp;gt; ((j-1)-1)/2&lt;/span&gt; &lt;span&gt;超出最后一个父节点的位置  </span><br><span class="line">&lt;/span&gt;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; k;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         k = ReSortMaxBranch(data, k, &lt;span&gt;2&lt;/span&gt; * k + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; * k + &lt;span&gt;2&lt;/span&gt;, j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (temp == k) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; </span><br><span class="line">&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildMaxHeapify(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = data.Count / &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;)  &lt;span&gt;//(data.Count-1)-1)/2为数列最大父节点索引</span><br><span class="line">&lt;/span&gt;&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; i;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 temp = ReSortMaxBranch(data, i, &lt;span&gt;2&lt;/span&gt; * i + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; * i + &lt;span&gt;2&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (temp !=&lt;span&gt; i)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; k =&lt;span&gt; i;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt; (k != temp &amp;amp;&amp;amp; temp &amp;lt;= data.Count / &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         k =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         temp = ReSortMaxBranch(data, temp, &lt;span&gt;2&lt;/span&gt; * temp + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; * temp + &lt;span&gt;2&lt;/span&gt;, data.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; </span><br><span class="line">&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ReSortMaxBranch(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; data, &lt;span&gt;int&lt;/span&gt; maxIndex, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastIndex)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (right &amp;gt;&lt;span&gt; lastIndex)  &lt;span&gt;//父节点只有一个子节点</span><br><span class="line">&lt;/span&gt;&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 temp =&lt;span&gt; left;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[left] &amp;gt;&lt;span&gt; data[right])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     temp =&lt;span&gt; left;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; temp =&lt;span&gt; right;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; </span><br><span class="line">&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (data[maxIndex] &amp;lt;&lt;span&gt; data[temp])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                Swap(data, maxIndex, temp);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; temp =&lt;span&gt; maxIndex;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：BuildMaxHeapify为排序前构建的最大堆数列方法，主要内容为从最后一个父节点开始往前将每个三角组合</p>
<p>（即父节点与它的两个子节点）符合父节点值最大的规则。ReSortMaxBranch为将三角调整为父节点值最大，</p>
<p>并返回该值之前的索引，用来判断是否进行了交换，以及原来的父节点值交换到了什么位置。在HeapSort里首先</p>
<p>构建了最大堆数列，然后将根节点交换到末尾，根节点不是最大值了，在while语句中对最大堆数列进行调整。</p>
<p>插曲：自从看了Martin Fowler大师《重构》第三版，我发现我更不喜欢写注释了。每次都想着尽量让方法的名字更贴切，</p>
<p>即使会造成方法的名字很长很丑。这算不算曲解了大师的意思啊！？上面的代码注释都是写博客的时候现加的（源代码很干净的。汗!）。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是插入排序的一种更高效的改进版本。</p>
<p>在前面介绍的插入排序，我们知道1.它对有序数列排序的效率是非常高的 2.要排序的数向前移动是一步步进行的导致插入排序效率低。</p>
<p>希尔排序正是利用第一点，改善第二点，达到更理想的效果。</p>
<p>原理：通过奇妙的步长，插入排序间隔步长的元素，随后逐渐缩短步长至1，实现数列的插入排序。 <a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">维基入口</a></p>
<p>疑问：可以想象到排序间隔步长的数，会逐渐让数列变得有序，提升最后步长为1时标准插入排序的效率。在维基上看到这么</p>
<p>一句话“可能<strong>希尔排序</strong>最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的”注意用词是‘可能’。我的疑问是</p>
<p>这是个正确的命题吗？如何证明呢？看维基上也是由果推因，说是如果不是这样，就不会排序那么快了。可这我感觉还是太牵强了，</p>
<p>哪位大哥发现相关资料，希望能分享出来，不胜感激。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShellSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; gap = data.Count / &lt;span&gt;2&lt;/span&gt;; gap &amp;gt; &lt;span&gt;0&lt;/span&gt;; gap /= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = gap; i &amp;lt; data.Count; i +=&lt;span&gt; gap)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     temp =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - gap; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; j -=&lt;span&gt; gap)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (data[j] &amp;gt;&lt;span&gt; temp)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                             data[j + gap] =&lt;span&gt; data[j];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (j == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                                 data[j] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                             data[j + gap] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：采用的步长是N&#x2F;2，每次取半，直至1。循环内部就是标准的插入排序。</p>
<p>——————</p>
<p>修正：修正后希尔排序才是真正牛叉的希尔啊！感谢@390218462的提出  </p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShellSortCorrect(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; gap = data.Count / &lt;span&gt;2&lt;/span&gt;; gap &amp;gt; &lt;span&gt;0&lt;/span&gt;; gap /= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = gap; i &amp;lt; data.Count; &lt;span&gt;i++&lt;/span&gt;&lt;span&gt;)      // &lt;span&gt;i+ = gap 改为了 i++</span><br><span class="line">&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     temp =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - gap; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; j -=&lt;span&gt; gap)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (data[j] &amp;gt;&lt;span&gt; temp)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                             data[j + gap] =&lt;span&gt; data[j];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (j == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                                 data[j] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                             data[j + gap] =&lt;span&gt; temp;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625206.jpg" class=""><img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625286.jpg" class="">

<p>——————</p>
<p>这里实现的貌似是最差的希尔排序。主要源于步长的选择。维基上有各种牛叉的“凌波微步”，极限在哪里，</p>
<p>喜欢挑战的同学可以去学习学习。看维基<a href="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a>里六种排序的测试，希尔最快，比快速排序还快！！我没实现啊！</p>
<p>只是对于神奇的步长更充满了敬畏。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种非比较型整数排序。</p>
<p>“非比较型”是什么意思呢？因为它内部使用的是桶排序，而桶排序是非比较型排序。</p>
<p>这里就要说说桶排序了。一个非常有意思的排序。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>原理：取一定数量（数列中的最大值）的编好序号的桶，将数列每个数放进编号为它的桶里，然后将不是空的桶依次倒出来，</p>
<p>就组成有序数列了。  <a href="http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">维基入口</a></p>
<p>好吧！聪明的人一眼就看出桶排序的破绽了。假设只有两个数1,10000，岂不是要一万个桶！？这确实是个问题啊！我也</p>
<p>没想出解决办法。我起初也以为桶排序就是一个通过牺牲空间来换取时间的排序算法，它不需要比较，所以是非比较型算法。</p>
<p>但看了<a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">有趣的演示</a>的<a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html">桶排序</a>后，发现世界之大，你没有解决，不代表别人没解决，睿智的人总是很多。</p>
<p>1，9999的桶排序实现：new Int[2];总共有两个数，得出最大数9999的位数4，取10的4次幂即10000作为分母，</p>
<p>要排序的数（1或9999）作为分子，并乘以数列总数2，即1*2&#x2F;10000,9999*2&#x2F;10000得到各自的位置0,1，完成排序。</p>
<p>如果是1,10000进行排序的话，上面的做法就需要稍微加一些处理——发现最大数是10的n次幂，就将它作为分母，并</p>
<p>放在数列末尾就好了。</p>
<p>如果是9999,10000进行排序的话，那就需要二维数组了，两个都在位置1，位置0没数。这个时候就需要在放</p>
<p>入每个位置时采用其它排序（比如插入排序）办法对这个位置的多个数排序了。</p>
<h4 id="为基数排序做个过渡，我这里实现了一个个位数桶排序"><a href="#为基数排序做个过渡，我这里实现了一个个位数桶排序" class="headerlink" title="为基数排序做个过渡，我这里实现了一个个位数桶排序"></a>为基数排序做个过渡，我这里实现了一个个位数桶排序</h4><p>涉及到了当重复的数出现的处理。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BucketSortOnlyUnitDigit(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] indexCounter = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.Count; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 indexCounter[data[i]]++&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] indexBegin = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 indexBegin[i] = indexBegin[i-1]+&lt;span&gt; indexCounter[i-1];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; tempList =&lt;span&gt; NewInstance(data, data.Count);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.Count; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; number =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 tempList[indexBegin[number]++] =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             data =&lt;span&gt; tempList;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：indexCounter进行对每个数出现的频率的统计。indexBegin存储每个数的起始索引。</p>
<p>比如 1 1 2，indexCounter统计到0个0,2个1,1个2。indexBegin计算出0,1,2的起始索引分别为</p>
<p>0,0,2。当1个1已取出排序，那索引将+1,变为0,1,2。这样就通过提前给重复的数空出位置，解决了</p>
<p>重复的数出现的问题。当然，你也可以考虑用二维数组来解决重复。</p>
<p>下面继续基数排序。</p>
<p>基数排序原理：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p>取得最大数的位数，从低位开始，每个位上进行桶排序。</p>
<p>实现如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; RadixSort(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; max = data[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; data.Count; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[i] &amp;gt;&lt;span&gt; max)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     max =&lt;span&gt; data[i];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; digit = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (max / &lt;span&gt;10&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 digit++&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 max /= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; digit; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt;[] indexCounter = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; tempList =&lt;span&gt; NewInstance(data, data.Count);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; data.Count; j++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; number = (data[j] % Convert.ToInt32(Math.Pow(&lt;span&gt;10&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;))) / Convert.ToInt32(Math.Pow(&lt;span&gt;10&lt;/span&gt;, i));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得出i+1位上的数&lt;/span&gt;</span><br><span class="line">&lt;span&gt;22&lt;/span&gt;                     indexCounter[number]++&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt;[] indexBegin = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;1&lt;/span&gt;; k &amp;lt; &lt;span&gt;10&lt;/span&gt;; k++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     indexBegin[k] = indexBegin[k - &lt;span&gt;1&lt;/span&gt;] + indexCounter[k - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; data.Count; k++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; number = (data[k] % Convert.ToInt32(Math.Pow(&lt;span&gt;10&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;))) / Convert.ToInt32(Math.Pow(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;, i));</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     tempList[indexBegin[number]++] =&lt;span&gt; data[k];</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 data =&lt;span&gt; tempList;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>过程解析：得出最大数的位数，从低位开始桶排序。我写的这个实现代码并不简洁，但逻辑更清晰。</p>
<p>后面测试的时候我们就会发现，按理来说这个实现也还行吧！ 但并不如想象的那么快！</p>
<p>循环的次数太多？（统计频率n次+9次计算+n次放到新的数组）*位数。</p>
<p>创建的新实例太多？(new int[10]两次+NewInstance is反射判断创建实例+new int[n])*位数</p>
<h2 id="测试比较"><a href="#测试比较" class="headerlink" title="测试比较"></a>测试比较</h2><p>添加随机数组，数组有序校验，微软Linq排序</p>
<p>代码如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] RandomSet(&lt;span&gt;int&lt;/span&gt; length, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; max)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[length];</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Random rand = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; result.Length; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 result[i] =&lt;span&gt; rand.Next(max);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; </span><br><span class="line">&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsAscOrdered(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.Count - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[i] &amp;gt; data[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; </span><br><span class="line">&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMicrosoft(IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             Stopwatch stopwatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            stopwatch.Start();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; result = data.OrderBy(a =&amp;gt;&lt;span&gt; a).ToList();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            stopwatch.Stop();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; methodName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestMicrosoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; methodName.Length;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt; - length; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 methodName += &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             Console.WriteLine(methodName +</span><br><span class="line">&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  IsAscOrdered:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + IsAscOrdered(result) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; stopwatch.Elapsed.TotalSeconds);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; </span><br><span class="line">&lt;span&gt;38&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>测试主体如下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] aa = RandomSet(&lt;span&gt;50000&lt;/span&gt;, &lt;span&gt;99999&lt;/span&gt;&lt;span&gt;);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int[] aa = OrderedSet(5000);&lt;/span&gt;</span><br><span class="line">&lt;span&gt; 5&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Array Length:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; aa.Length);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)SelectSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)BubbleSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)BubbleSortImprovedWithFlag, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)BubbleCocktailSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)InsertSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)InsertSortImprovedWithBinarySearch, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)QuickSortStrict, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)QuickSortRelax, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)QuickSortRelaxImproved, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             RunTheMethod((Func&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;, IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)MergeSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)ShellSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             RunTheMethod((Func&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;, IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)RadixSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             RunTheMethod((Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)HeapSort, aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             TestMicrosoft(aa.Clone() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            Console.Read();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; </span><br><span class="line">&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RunTheMethod(Func&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;, IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; method, IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             Stopwatch stopwatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            stopwatch.Start();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; result =&lt;span&gt; method(data);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            stopwatch.Stop();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; methodName =&lt;span&gt; method.Method.Name;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; methodName.Length;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt; - length; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 methodName += &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             Console.WriteLine(methodName +</span><br><span class="line">&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  IsAscOrdered:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + IsAscOrdered(result) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; stopwatch.Elapsed.TotalSeconds);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; </span><br><span class="line">&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RunTheMethod(Action&amp;lt;IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; method, IList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; data)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             Stopwatch stopwatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            stopwatch.Start();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            method(data);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            stopwatch.Stop();</span><br><span class="line">&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; methodName =&lt;span&gt; method.Method.Name;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; methodName.Length;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt; - length; i++&lt;span&gt;)</span><br><span class="line">&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            &#123;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 methodName += &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            &#125;</span><br><span class="line">&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             Console.WriteLine(methodName +</span><br><span class="line">&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  IsAscOrdered:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + IsAscOrdered(data) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; stopwatch.Elapsed.TotalSeconds);</span><br><span class="line">&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625066.gif" class="" title="复制代码">

<p>剩余代码折叠在此处</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625323.gif" class=""> View Code

<p>测试设备：win8(64位)，i7-3630QM,8G内存，vs2012</p>
<p>测试结果：</p>
<p>100000,50000,10000,5000,1000,100依次是：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625384.jpg" class="">

<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625426.jpg" class=""><img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625487.jpg" class=""><img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625541.jpg" class=""><img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625607.jpg" class=""><img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625659.jpg" class="">

<p>结果分析：可以看出在大数组的时候，微软自带排序更接近快速排序。而当数组变小时，速度却没有明显提升，甚至变得更慢，</p>
<p>比如1000和100。可以推断出在数组足够小的时候，比较已经不是影响这个方法主要因素。而根据它对大数组的表现。我们可以</p>
<p>推断出它应该用的是快速排序。反编译验证下：</p>
<img src="/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84C%E5%AE%9E%E7%8E%B0/IMG-20250704185625705.jpg" class="">

<p>在System.Linq.EnumerableSorter下。有兴趣的同学可以去看下详细实现。</p>
<p>维基上也有个测试。硬件没我的好。时间是我测试结果时间的几百倍。有兴趣的同学可以比较下。</p>
<p>在上面的测试中，我们可以看到快速最快，归并其次，冒泡最慢（维基上是希尔最快，估计使用的是某种神奇的步长）。</p>
<p>在我这里，以前实现的希尔还不如二分查找优化版的快，修正后希尔快了相当多，上面测试的希尔排序是以前错误的实现。</p>
<p>修正后的实现测试效果请点击右侧导航到希尔排序查看。希尔排序是一种神奇又有潜力的算法。步长不好会很挫！</p>
<p>而基数排序却是比平均时间复杂度为o(nlogn)的堆排序，归并排序，快速排序还要慢的，虽然它的平均时间复杂度为o(n)。</p>
<p>冒泡标识优化版对随机数列结果优化不明显，鸡尾酒版优化可以看到，但也不是很厉害。</p>
<p>插入排序二分查找优化版优化比较明显。我优化的快速排序QuickSortRelaxImproved优化也不明显。</p>
<p>以上是随机数列的测试结果，最大值为99999。</p>
<p>而对于有序数列，这些方法表现又会如何呢？</p>
<p>我这里就不演示了。<a href="http://www.cnblogs.com/fatbird/p/SortAlgorithm.html">本文</a>末尾会附上demo，大家可以自行测试。</p>
<p>有意思的是:</p>
<p>我在测试有序数列的时候，QuickSortStrict方法栈溢出了（stack overflow exception）。这个异常</p>
<p>是让我去stackoverflow搜寻答案吗？哈哈！我确信我的方法不是无限循环。跳过一堆链接。。。我是</p>
<p>在测试10000个数排序的时候发生的错误。我跟踪后发现大约在9400多次递归的时候，栈溢出。找啊找</p>
<p>终于找见了一个类似的<a href="http://stackoverflow.com/questions/4106708/runtime-exception-recursion-too-deep">问题</a>。上面说如果一个递归9000多次而没有返回值，也会报栈溢出的。而这个方法</p>
<p>对于10000个有序数列，确实每次减少一个数地递归，次数会超过限制。</p>
<p>我的算法理论不怎么好，对于时间复杂度和空间复杂度，还有稳定度，搞得也不怎么清楚，只知道个大致的  </p>
<p>意思。各位要笔试面试的朋友可以去<a href="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.AE.80.E8.A6.81.E6.AF.94.E8.BE.83">维基百科这个表</a>来了解学习。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得使用IList<int>更贴近数列，更能展现基本的操作。所以我的实现中都没有将它强制转化为List<int></p>
<p>或者int[]来调用微软封装的方法。这样说来，题目说C#实现倒快有点名不副实了。不过这样却也方便了其它语言</p>
<p>朋友。比如将我这篇博文里的实现随便改改，就可以说是另一个语言版本的8种排序算法了。哈哈！在这里，</p>
<p>我想说下这次学习排序对我的意义：老久不怎么动脑了，突然动起来，磨磨唧唧地得出结果，最后倒也有点成就感！</p>
<p>在学习过程中，经常会脑子转不过弯，想不通的，只是走在路上或者睡觉前突然灵感一现，有点小惊喜的感觉！</p>
<p>这大概就是进步的特征吧！哈哈！这次写demo+写博客花费了不少时间，倒也收获颇多，尤其在我将8种</p>
<p>排序都实现之前，没进行过一次测试，全部实现完成后，测试时各种索引越界+无限循环+各种问题，没几个</p>
<p>能跑通的，到后来的几乎都没有问题，也算是锻炼了思维，找出错原因的能力。本篇是自我学习的一个总结，</p>
<p>要学习及锻炼的园友，还望一定自己实现一下，可以和我的比较一下，解除疑惑或者提出改进。</p>
<h4 id="主要参考：维基百科，有趣的演示"><a href="#主要参考：维基百科，有趣的演示" class="headerlink" title="主要参考：维基百科，有趣的演示"></a>主要参考：<a href="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">维基百科</a>，<a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">有趣的演示</a></h4><h4 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a><a href="https://files.cnblogs.com/fatbird/SortAlgorithmDemo.zip">Demo源码</a></h4><p>PS:我打算三月份去广州发展，主要会Asp.net mvc+jquery（不介意学习新的技术[除了webform]及语言[除了java]）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp排序算法小结</title>
    <url>/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CSharp%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>算法这个东西其实在开发中很少用到，特别是web开发中，但是算法也很重要，因为任何的程序，任何的软件，都是由很多的算法和数据结构组成的。但是这不意味着算法对于每个软件设计人员的实际工作都是很重要的。每个项目特点和需求特殊也导致算法运用场景上不同。但是个人觉得算法运用的好的话会给自己在程序设计的时候提供比较好的思路。下面就对一些排序算法小结一下，就当做自己的一个笔记吧。</p>
<p><strong>插入排序</strong></p>
<p> <strong>1.简介</strong></p>
<p>插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p><strong>2.算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br>1.从第一个元素开始，该元素可以认为已经被排序<br>2.取出下一个元素，在已经排序的元素序列中从后向前扫描<br>3.如果该元素（已排序）大于新元素，将该元素移到下一位置<br>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>5.将新元素插入到该位置后<br>6.重复步骤2~5<br>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找排序。</p>
<p><strong>3.使用插入排序为一列数字进行排序的过程</strong> </p>
<p><img src="https://images0.cnblogs.com/blog/373130/201402/181030498429191.gif"></p>
<p><img src="https://images0.cnblogs.com/blog/373130/201402/181031003601771.gif"></p>
<p><strong>最差时间复杂度 <img src="http://upload.wikimedia.org/math/c/d/6/cd641c6cabc83e0f7ff510bf812feca1.png" alt="O(n^{2})"></strong> </p>
<p>最优时间复杂度 <img src="http://upload.wikimedia.org/math/7/b/a/7ba55e7c64a9405a0b39a1107e90ca94.png" alt="O(n)"></p>
<p>平均时间复杂度<img src="http://upload.wikimedia.org/math/c/d/6/cd641c6cabc83e0f7ff510bf812feca1.png" alt="O(n^{2})"></p>
<p><strong>4.C#实现</strong></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code>    /// &lt;summary&gt;
    /// 插入排序 /// &lt;/summary&gt;
    public class InsertionSorter
    &#123; public void Sort(int\[\] list)
        &#123; for (int i = 1; i &lt; list.Length; ++i)
            &#123; int t = list\[i\]; int j = i; while ((j &gt; 0) &amp;&amp; (list\[j - 1\] &gt; t))
                &#123;
                    list\[j\] \= list\[j - 1\]; \--j;
                &#125;
                list\[j\] \= t;
            &#125;

        &#125;
    &#125;
</code></pre>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>数组</p>
<p>int[] iArrary &#x3D; new int[] { 1, 5, 3, 6, 10, 55, 9, 2, 87, 12, 34, 75, 33, 47 };</p>
<p><strong>希尔排序</strong></p>
<p> <strong>1.简介</strong></p>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p><strong>2.算法实现</strong></p>
<p>原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。V. Pratt的书[1] 对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。<br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i +&#x3D; step_size而不是i++）。</p>
<p><strong>3.排序过程</strong></p>
<p><img src="https://images0.cnblogs.com/blog/373130/201402/181058308243697.gif"></p>
<p>最差时间复杂度 根据步长串行的不同而不同。<img src="http://upload.wikimedia.org/math/2/0/0/20062c989c6b1067c07dfdeb30efbfb7.png" alt="O(n\log^2 n)"></p>
<p>最优时间复杂度 O(<em>n</em>)</p>
<p>平均时间复杂度  根据步长串行的不同而不同。</p>
<p><strong>4.C#实现</strong></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code>    /// &lt;summary&gt;
    /// 希尔排序 /// &lt;/summary&gt;
    public class ShellSorter
    &#123; public void Sort(int\[\] list)
        &#123; int inc; for (inc = 1; inc &lt;= list.Length / 9; inc = 3 \* inc + 1) ; for (; inc &gt; 0; inc /= 3)
            &#123; for (int i = inc + 1; i &lt;= list.Length; i += inc)
                &#123; int t = list\[i - 1\]; int j = i; while ((j &gt; inc) &amp;&amp; (list\[j - inc - 1\] &gt; t))
                    &#123;
                        list\[j \- 1\] = list\[j - inc - 1\];
                        j \-= inc;
                    &#125;
                    list\[j \- 1\] = t;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>选择排序</strong></p>
<p> 1.简介</p>
<p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<p>2.实现过程</p>
<p><img src="https://images0.cnblogs.com/blog/373130/201402/181110130383862.gif"></p>
<p>最差时间复杂度 <em>О(n²)</em></p>
<p><em>最优时间复杂度 <em>О(n²)</em></em></p>
<p>平均时间复杂度 <em>О(n²)</em></p>
<p><strong>3.C#实现</strong></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code>    /// &lt;summary&gt;
    /// 选择排序 /// &lt;/summary&gt;
    public class SelectionSorter
    &#123; // public enum comp &#123;COMP\_LESS,COMP\_EQUAL,COMP\_GRTR&#125;;
        private int min; // private int m=0;
        public void Sort(int\[\] list)
        &#123; for (int i = 0; i &lt; list.Length - 1; ++i)
            &#123;
                min \= i; for (int j = i + 1; j &lt; list.Length; ++j)
                &#123; if (list\[j\] &lt; list\[min\])
                        min \= j;
                &#125; int t = list\[min\];
                list\[min\] \= list\[i\];
                list\[i\] \= t; // Console.WriteLine(&quot;&#123;0&#125;&quot;,list\[i\]);
</code></pre>
<p> }</p>
<pre><code>        &#125;
    &#125;
</code></pre>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>冒泡排序</strong></p>
<p> <strong>1.简介</strong></p>
<p>冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序对n个项目需要O(n^{2})的比较次数，且可以原地排序。尽管这个算法是最简单了解和实作的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。<br>冒泡排序是与插入排序拥有相等的执行时间，但是两种法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要O(n^{2})次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地执行（O(n^{2})），而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次执行时，使用一个旗标来表示有无需要交换的可能，也有可能把最好的复杂度降低到O(n)。在这个情况，在已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序和比较大小反过来，也可以稍微地改进效率。有时候称为往返排序，因为算法会从数列的一端到另一端之间穿梭往返。</p>
<p><strong>2.算法实现</strong><br>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </p>
<p><strong>3.实现过程</strong></p>
<p><img src="https://images0.cnblogs.com/blog/373130/201402/181136161673239.gif"></p>
<p>最差时间复杂度 <img src="http://upload.wikimedia.org/math/c/d/6/cd641c6cabc83e0f7ff510bf812feca1.png" alt="O(n^{2})"></p>
<p>最优时间复杂度 <img src="http://upload.wikimedia.org/math/7/b/a/7ba55e7c64a9405a0b39a1107e90ca94.png" alt="O(n)"></p>
<p>平均时间复杂度 <img src="http://upload.wikimedia.org/math/c/d/6/cd641c6cabc83e0f7ff510bf812feca1.png" alt="O(n^{2})"></p>
<p><strong>4.C#实现</strong></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code>   /// &lt;summary&gt;
    /// 冒泡排序 /// &lt;/summary&gt;
    public class bubblesort
    &#123; public void BubbleSort(int\[\] R)
        &#123; int i, j, temp; //交换标志 
            bool exchange; for (i = 0; i &lt; R.Length; i++) //最多做R.Length-1趟排序 
</code></pre>
<p> {<br>                    exchange = false; &#x2F;&#x2F;本趟排序开始前，交换标志应为假<br>                    for (j &#x3D; R.Length - 2; j &gt;&#x3D; i; j–)<br>                    { if (R[j + 1] &lt; R[j])　&#x2F;&#x2F;交换条件<br> {<br>                            temp = R[j + 1];<br>                            R[j + 1] &#x3D; R[j];<br>                            R[j] = temp;<br>                            exchange = true; &#x2F;&#x2F;发生了交换，故将交换标志置为真<br> }<br>                    } if (!exchange) &#x2F;&#x2F;本趟排序未发生交换，提前终止算法<br> { break;<br>                    }<br>                }<br>            }<br>        }</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C#排序算法的比较</title>
    <url>/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CSharp%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="C-排序算法的比较"><a href="#C-排序算法的比较" class="headerlink" title="C#排序算法的比较"></a>C#排序算法的比较</h1><p><strong>首先通过图表比较不同排序算法的时间复杂度和稳定性。</strong></p>
<table><tbody><tr><td><p><strong>排序方法</strong></p></td><td><p><strong>平均时间</strong></p></td><td><p><strong>最坏情况</strong></p></td><td><p><strong>最好情况</strong></p></td><td><p><strong>辅助空间</strong></p></td><td><p><strong>稳定性</strong></p></td></tr><tr><td>直接插入排序</td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(n)</p></td><td><p>O(1)</p></td><td>是</td></tr><tr><td>冒泡排序</td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(n)</p></td><td><p>O(1)</p></td><td>是</td></tr><tr><td>简单选择排序</td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(1)</p></td><td>是</td></tr><tr><td>希尔排序</td><td>-</td><td><p>O(nlog<sub>2</sub>n)~O(n<sup>2</sup>)</p></td><td><p>O(nlog<sub>2</sub>n)~O(n<sup>2</sup>)</p></td><td><p>O(1)</p></td><td>否</td></tr><tr><td>快速排序</td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(n<sup>2</sup>)</p></td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(log<sub>2</sub>n)</p></td><td>否</td></tr><tr><td>堆排序</td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(1)</p></td><td>否</td></tr><tr><td>2-路归并排序</td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(nlog<sub>2</sub>n)</p></td><td><p>O(n)</p></td><td>是</td></tr><tr><td>基数排序</td><td>O(d(n + rd))</td><td>O(d(n + rd))</td><td>O(d(n + rd))</td><td>O(rd)</td><td>是</td></tr></tbody></table>

<p>注：1. 算法的时间复杂度一般情况下指最坏情况下的渐近时间复杂度。</p>
<p>        2. 排序算法的稳定性会对多关键字排序产生影响。</p>
<p><strong>下面通过C#代码说明不同的排序算法</strong></p>
<p><strong>插入排序</strong></p>
<p><strong>时间复杂度：平均情况—O(n<sup><span>2</span></sup>) 最坏情况—O(n<sup><span>2</span></sup>) 辅助空间：O(1) 稳定性：稳定</strong></p>
<p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p><strong>希尔排序(shell)</strong></p>
<p><strong>时间复杂度：理想情况—O(nlog<sub><span>2</span></sub>n) 最坏情况—O(n<sup><span>2</span></sup>) 稳定性：不稳定</strong></p>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p><strong>冒泡排序</strong></p>
<p><strong>时间复杂度：平均情况—O(n<sup><span>2</span></sup>) 最坏情况—O(n<sup><span>2</span></sup>) 辅助空间：O(1) 稳定性：稳定</strong></p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<p><strong>快速排序</strong></p>
<p><strong>时间复杂度：平均情况—O(nlog<sub><span>2</span></sub>n) 最坏情况—O(n<sup><span>2</span></sup>) 辅助空间：O(log<sub><span>2</span></sub>n) 稳定性：不稳定</strong></p>
<p>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;&#x3D; a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;&#x3D; j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。</p>
<p><strong>选择排序</strong></p>
<p><strong>时间复杂度：平均情况—O(n<sup><span>2</span></sup>) 最坏情况—O(n<sup><span>2</span></sup>) 辅助空间：O(1) 稳定性：不稳定</strong></p>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p><strong>堆排序</strong></p>
<p><strong>时间复杂度：平均情况—O(nlog<sub><span>2</span></sub>n) 最坏情况—O(nlog<sub><span>2</span></sub>n) 辅助空间：O(1) 稳定性：不稳定</strong></p>
<p>我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n的序列，堆排序的过程是从第n&#x2F;2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n&#x2F;2-1, n&#x2F;2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n&#x2F;2个父节点交换把后面一个元素交换过去了，而第n&#x2F;2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法</p>
<p><strong>归并排序</strong></p>
<p><strong>时间复杂度：平均情况—O(nlog<sub><span>2</span></sub>n) 最坏情况—O(nlog<sub><span>2</span></sub>n) 辅助空间：O(n) 稳定性：稳定</strong></p>
<p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C#经典排序算法大全</title>
    <url>/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CSharp%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="C-经典排序算法大全"><a href="#C-经典排序算法大全" class="headerlink" title="C# 经典排序算法大全"></a>C# 经典排序算法大全</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>文章浏览阅读84次。C# 经典排序算法大全选择排序using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace sorter{    public class SelectionSorter    {        private int min;       …_c# case复杂排序</p>
</blockquote>
<hr>
<h2 id="C-经典排序算法大全-1"><a href="#C-经典排序算法大全-1" class="headerlink" title="C# 经典排序算法大全"></a>C# 经典排序算法大全</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">sorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectionSorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> min;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length - <span class="number">1</span>; ++i)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">min = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; arr.Length; ++j)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">min = j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> t = arr[min];</span><br><span class="line"></span><br><span class="line">arr[min] = arr[i];</span><br><span class="line"></span><br><span class="line">arr[i] = t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arrInt = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">SelectionSorter selSor = <span class="keyword">new</span> SelectionSorter();</span><br><span class="line"></span><br><span class="line">selSor.Sort(arrInt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> arrInt)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">sorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EbullitionSorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, j, temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((j &lt; arr.Length) &amp;&amp; (!done))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.Length - j; i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">temp = arr[i];</span><br><span class="line"></span><br><span class="line">arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr[i + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arrInt = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">EbullitionSorter selSor = <span class="keyword">new</span> EbullitionSorter();</span><br><span class="line"></span><br><span class="line">selSor.Sort(arrInt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> arrInt)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高速排序"><a href="#高速排序" class="headerlink" title="高速排序"></a>高速排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">sorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuickSorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> l, <span class="keyword">ref</span> <span class="built_in">int</span> r</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line"></span><br><span class="line">temp = l;</span><br><span class="line"></span><br><span class="line">l = r;</span><br><span class="line"></span><br><span class="line">r = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] list, <span class="built_in">int</span> low, <span class="built_in">int</span> high</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pivot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (high &lt;= low)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (high == low + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list[low] &gt; list[high])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">swap(<span class="keyword">ref</span> list[low], <span class="keyword">ref</span> list[high]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">pivot = list[mid];</span><br><span class="line"></span><br><span class="line">swap(<span class="keyword">ref</span> list[low], <span class="keyword">ref</span> list[mid]);</span><br><span class="line"></span><br><span class="line">l = low + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">r = high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; list[l] &lt; pivot)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">l++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (list[r] &gt;= pivot)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">r--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">swap(<span class="keyword">ref</span> list[l], <span class="keyword">ref</span> list[r]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (l &lt; r);</span><br><span class="line"></span><br><span class="line">list[low] = list[r];</span><br><span class="line"></span><br><span class="line">list[r] = pivot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (low + <span class="number">1</span> &lt; r)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Sort(list, low, r - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r + <span class="number">1</span> &lt; high)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Sort(list, r + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arrInt = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">QuickSorter selSor = <span class="keyword">new</span> QuickSorter();</span><br><span class="line"></span><br><span class="line">selSor.Sort(arrInt, <span class="number">0</span>, arrInt.Length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> arrInt)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">sorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InsertionSorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> t = arr[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((j &gt; <span class="number">0</span>) &amp;&amp; (arr[j - <span class="number">1</span>] &gt; t))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">--j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[j] = t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arrInt = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">InsertionSorter selSor = <span class="keyword">new</span> InsertionSorter();</span><br><span class="line"></span><br><span class="line">selSor.Sort(arrInt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> arrInt)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">sorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellSorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> inc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (inc = <span class="number">1</span>; inc &lt;= arr.Length / <span class="number">9</span>; inc = <span class="number">3</span> * inc + <span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; inc &gt; <span class="number">0</span>; inc /= <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = inc + <span class="number">1</span>; i &lt;= arr.Length; i += inc)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> t = arr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((j &gt; inc) &amp;&amp; (arr[j - inc - <span class="number">1</span>] &gt; t))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">arr[j - <span class="number">1</span>] = arr[j - inc - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">j -= inc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[j - <span class="number">1</span>] = t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arrInt = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">ShellSorter selSor = <span class="keyword">new</span> ShellSorter();</span><br><span class="line"></span><br><span class="line">selSor.Sort(arrInt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> arrInt)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Merge</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Function</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> Groups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> CopyGroups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> mergerows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] Array27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random ran = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Function</span>(<span class="params"><span class="built_in">int</span> length</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Array27 = <span class="keyword">new</span> <span class="built_in">int</span>[length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"></span><br><span class="line">Array27[i] = ran.Next(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToMergeSort</span>()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MergeSort(Array27);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToRecursiveMergeSort</span>()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RecursiveMergeSort(Array27, <span class="number">0</span>, Array27.Length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToNaturalMergeSort</span>()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NaturalMergeSort(Array27);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecursiveMergeSort</span>(<span class="params"><span class="built_in">int</span>[] Array, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RecursiveMergeSort(Array, left, middle);</span><br><span class="line"></span><br><span class="line">RecursiveMergeSort(Array, middle + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">MergeOne(Array, left, middle, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeOne</span>(<span class="params"><span class="built_in">int</span>[] Array, <span class="built_in">int</span> left, <span class="built_in">int</span> middle, <span class="built_in">int</span> right</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> leftindex = left;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> rightindex = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] merge = <span class="keyword">new</span> <span class="built_in">int</span>[right + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (leftindex &lt;= middle &amp;&amp; rightindex &lt;= right)</span><br><span class="line"></span><br><span class="line">merge[index++] = (Array[leftindex] - Array[rightindex]) &gt;= <span class="number">0</span> ? Array[rightindex++] : Array[leftindex++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftindex &lt;= middle)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = leftindex; i &lt;= middle; i++)</span><br><span class="line"></span><br><span class="line">merge[index++] = Array[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rightindex &lt;= right)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = rightindex; i &lt;= right; i++)</span><br><span class="line"></span><br><span class="line">merge[index++] = Array[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = left; i &lt;= right; i++)</span><br><span class="line"></span><br><span class="line">Array[i] = merge[index++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeSort</span>(<span class="params"><span class="built_in">int</span>[] Array</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] merge = <span class="keyword">new</span> <span class="built_in">int</span>[Array.Length];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> P = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> ENumb = (<span class="built_in">int</span>)Math.Pow(<span class="number">2</span>, P);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ENumb &lt; Array.Length)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> TorFAndrightindex = index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TorFAndrightindex &lt;= Array.Length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">MergeTwo(Array, merge, index, ENumb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">index += <span class="number">2</span> * ENumb;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">P++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeTwo</span>(<span class="params"><span class="built_in">int</span>[] Array, <span class="built_in">int</span>[] merge, <span class="built_in">int</span> index, <span class="built_in">int</span> ENumb</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> left = index;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> middle = left + ENumb - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (middle &gt;= Array.Length)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">middle = index;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mergeindex = index;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> middleTwo = (index + ENumb - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">right = index + ENumb + ENumb - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right &gt;= Array.Length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">right = Array.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= middle &amp;&amp; middleTwo &lt;= right)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">merge[mergeindex++] = Array[left] &gt;= Array[middleTwo] ? Array[middleTwo++] : Array[left++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left &lt;= middle)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= middle &amp;&amp; mergeindex &lt; merge.Length)</span><br><span class="line"></span><br><span class="line">merge[mergeindex++] = Array[left++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (middleTwo &lt;= right)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (middleTwo &lt;= right)</span><br><span class="line"></span><br><span class="line">merge[mergeindex++] = Array[middleTwo++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right + <span class="number">1</span> &gt;= Array.Length)</span><br><span class="line"></span><br><span class="line">Copy(Array, merge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NaturalMergeSort</span>(<span class="params"><span class="built_in">int</span>[] Array</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,] PointsSymbol = LinearPoints(Array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PointsSymbol[<span class="number">0</span>, <span class="number">1</span>] == Array.Length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">NaturalMerge(Array, PointsSymbol);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NaturalMerge</span>(<span class="params"><span class="built_in">int</span>[] Array, <span class="built_in">int</span>[,] PointsSymbol</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> left;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> leftend;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> rightend;</span><br><span class="line"></span><br><span class="line">mergerows = GNumberTwo(Groups);</span><br><span class="line"></span><br><span class="line">CopyGroups = Groups;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] TempArray = <span class="keyword">new</span> <span class="built_in">int</span>[Array.Length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,] TempPointsSymbol = <span class="keyword">new</span> <span class="built_in">int</span>[mergerows, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row != CopyGroups - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">left = PointsSymbol[row, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">leftend = PointsSymbol[row, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">right = PointsSymbol[row + <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">rightend = PointsSymbol[row + <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">MergeThree(Array, TempArray, left, leftend, right, rightend);</span><br><span class="line"></span><br><span class="line">MergePointSymbol(PointsSymbol, TempPointsSymbol, row);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">默认剩下的单独一个子数组已经虚拟合并。然后Copy进TempArray。</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> TempRow = PointsSymbol[row, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> TempCol = PointsSymbol[row, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (TempRow &lt;= TempCol)</span><br><span class="line"></span><br><span class="line">TempArray[TempRow] = Array[TempRow++];</span><br><span class="line"></span><br><span class="line">TempPointsSymbol[row / <span class="number">2</span>, <span class="number">0</span>] = PointsSymbol[row, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">TempPointsSymbol[row / <span class="number">2</span>, <span class="number">1</span>] = PointsSymbol[row, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">row += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TempPointsSymbol[<span class="number">0</span>, <span class="number">1</span>] == Array.Length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (row &lt;= CopyGroups - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Copy(Array, TempArray);</span><br><span class="line"></span><br><span class="line">UpdatePointSymbol(PointsSymbol, TempPointsSymbol, row);</span><br><span class="line"></span><br><span class="line">mergerows = GNumber(mergerows);</span><br><span class="line"></span><br><span class="line">CopyGroups = GNumberTwo(CopyGroups);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PointsSymbol[<span class="number">0</span>, <span class="number">1</span>] == Array.Length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GNumber</span>(<span class="params"><span class="built_in">int</span> Value</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Value % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Value /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">Value -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GNumberTwo</span>(<span class="params"><span class="built_in">int</span> Value</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Value % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">mergerows = Value / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">mergerows = Value / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mergerows;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeThree</span>(<span class="params"><span class="built_in">int</span>[] Array, <span class="built_in">int</span>[] Temp, <span class="built_in">int</span> left, <span class="built_in">int</span> leftend, <span class="built_in">int</span> right, <span class="built_in">int</span> rightend</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> index = left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= leftend &amp;&amp; right &lt;= rightend)</span><br><span class="line"></span><br><span class="line">Temp[index++] = Array[left] &gt;= Array[right] ? Array[right++] : Array[left++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= leftend)</span><br><span class="line"></span><br><span class="line">Temp[index++] = Array[left++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt;= rightend)</span><br><span class="line"></span><br><span class="line">Temp[index++] = Array[right++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergePointSymbol</span>(<span class="params"><span class="built_in">int</span>[,] PointsSymbol, <span class="built_in">int</span>[,] TempPointsSymbol, <span class="built_in">int</span> row</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> rowindex = row / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">TempPointsSymbol[rowindex, <span class="number">0</span>] = PointsSymbol[row, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">TempPointsSymbol[rowindex, <span class="number">1</span>] = PointsSymbol[row + <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdatePointSymbol</span>(<span class="params"><span class="built_in">int</span>[,] PointsSymbol, <span class="built_in">int</span>[,] TempPointsSymbol, <span class="built_in">int</span> rows</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; row &lt; TempPointsSymbol.GetLength(<span class="number">0</span>); row++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> col = <span class="number">0</span>; col &lt; <span class="number">2</span>; col++)</span><br><span class="line"></span><br><span class="line">PointsSymbol[row, col] = TempPointsSymbol[row, col];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; row &lt; PointsSymbol.GetLength(<span class="number">0</span>); row++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> col2 = <span class="number">0</span>; col2 &lt; <span class="number">2</span>; col2++)</span><br><span class="line"></span><br><span class="line">PointsSymbol[row, col2] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补剩下的index组，</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; int row3 &#x3D; TempPointsSymbol.GetLength(0); &#x2F;&#x2F; PointsSymbol[row3, 0] &#x3D; PointsSymbol[rows, 0]; &#x2F;&#x2F; PointsSymbol[row3, 1] &#x3D; PointsSymbol[rows, 1]; &#x2F;&#x2F; &#x2F;&#x2F;后面的清零 &#x2F;&#x2F; for (int row4 &#x3D; row3 + 1; row4 &lt; PointsSymbol.GetLength(0); row4++) &#x2F;&#x2F; { &#x2F;&#x2F; for (int col4 &#x3D; 0; col4 &lt; 2; col4++) &#x2F;&#x2F; PointsSymbol[row4, col4] &#x3D; 0; &#x2F;&#x2F; } &#x2F;&#x2F;} } public int[,] LinearPoints(int[] Array) { Groups &#x3D; 1; int StartPoint &#x3D; 0; int row &#x3D; 0; int col &#x3D; 0; &#x2F;&#x2F;最糟糕的情况就是有Array.Length行。 int[,] PointsSet &#x3D; new int[Array.Length, 2]; &#x2F;&#x2F;线性扫描Array，划分数组 &#x2F;&#x2F;初始前index&#x3D;0 PointsSet[row, col] &#x3D; 0; do { &#x2F;&#x2F;推断升序子数组终于的index开关 bool Judge &#x3D; false; &#x2F;&#x2F;从Array第二个数推断是否要结束或者是否是升序子数组. while (++StartPoint &lt; Array.Length &amp;&amp; Array[StartPoint] &lt; Array[StartPoint - 1]) { &#x2F;&#x2F;打开第一个升序子数组结束的index开关 Judge &#x3D; true; &#x2F;&#x2F;又一次開始第二个升序子数组的前index PointsSet[row, col + 1] &#x3D; StartPoint - 1; &#x2F;&#x2F;计算子数组个数 Groups++; &#x2F;&#x2F;换行记录自然子数组的index row++; break; &#x2F;&#x2F;–StartPoint; } &#x2F;&#x2F;升序子数组结束index if (Judge) PointsSet[row, col] &#x3D; StartPoint; &#x2F;&#x2F;else &#x2F;&#x2F; –StartPoint; } while (StartPoint &lt; Array.Length); &#x2F;&#x2F;终于index&#x3D;StartPoint - 1，可是糟糕情况下还有剩余若干行为： 0,0 … PointsSet[row, col + 1] &#x3D; StartPoint - 1; &#x2F;&#x2F;调用展示方法 DisplaySubarray(Array, PointsSet, Groups); return PointsSet; } public void DisplaySubarray(int[] Array, int[,] PointsSet, int Groups) { Console.WriteLine(“Subarray is {0}:”, Groups); &#x2F;&#x2F;展示子数组的前后index for (int r &#x3D; 0; r &lt; Groups; r++) { for (int c &#x3D; 0; c &lt; PointsSet.GetLength(1); c++) { Console.Write(PointsSet[r, c]); if (c &lt; PointsSet.GetLength(1) - 1) Console.Write(“,”); } Console.Write(“\t\t”); } Console.WriteLine(); &#x2F;&#x2F;展示分出的子数组 for (int v &#x3D; 0; v &lt; Groups; v++) { int i &#x3D; 1; for (int r &#x3D; PointsSet[v, 0]; r &lt;&#x3D; PointsSet[v, 1]; r++) { Console.Write(Array[r] + “ “); i++; } if (i &lt;&#x3D; 3) Console.Write(“\t\t”); else Console.Write(“\t”); if (PointsSet[v, 1] &#x3D;&#x3D; Array.Length) break; } } public void Copy(int[] Array, int[] merge) { &#x2F;&#x2F;一部分排好序的元素替换掉原来Array中的元素 for (int i &#x3D; 0; i &lt; Array.Length; i++) { Array[i] &#x3D; merge[i]; } } &#x2F;&#x2F;输出 public override string ToString() { string temporary &#x3D; string.Empty; foreach (var element in Array27) temporary +&#x3D; element + “ “; temporary +&#x3D; “\n”; return temporary; } } class Program { static void Main(string[] args) { while (true) { Console.WriteLine(“请选择：”); Console.WriteLine(“1.归并排序（非递归）”); Console.WriteLine(“2.归并排序（递归）”); Console.WriteLine(“3.归并排序（自然合并）”); Console.WriteLine(“4.退出”); int Arraynum &#x3D; Convert.ToInt32(Console.ReadLine()); switch (Arraynum) { case 4: Environment.Exit(0); break; case 1: Console.WriteLine(“Please Input Array Length”); int Leng271 &#x3D; Convert.ToInt32(Console.ReadLine()); Function obj1 &#x3D; new Function(Leng271); Console.WriteLine(“The original sequence:”); Console.WriteLine(obj1); Console.WriteLine(“‘MergeSort’ Finaly Sorting Result:”); obj1.ToMergeSort(); Console.WriteLine(obj1); break; case 2: Console.WriteLine(“Please Input Array Length”); int Leng272 &#x3D; Convert.ToInt32(Console.ReadLine()); Function obj2 &#x3D; new Function(Leng272); Console.WriteLine(“The original sequence:”); Console.WriteLine(obj2); Console.WriteLine(“‘RecursiveMergeSort’ Finaly Sorting Result:”); obj2.ToRecursiveMergeSort(); Console.WriteLine(obj2); break; case 3: Console.WriteLine(“Please Input Array Length”); int Leng273 &#x3D; Convert.ToInt32(Console.ReadLine()); Function obj3 &#x3D; new Function(Leng273); Console.WriteLine(“The original sequence:”); Console.WriteLine(obj3); obj3.ToNaturalMergeSort(); Console.WriteLine(); Console.WriteLine(); Console.WriteLine(“‘NaturalMergeSort’ Finaly Sorting Result:”); Console.WriteLine(obj3); break; } } } } }</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Merge</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RadixSorter</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">RadixSort</span>(<span class="params"><span class="built_in">int</span>[] ArrayToSort, <span class="built_in">int</span> digit</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">1</span>; k &lt;= digit; k++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] tmpArray = <span class="keyword">new</span> <span class="built_in">int</span>[ArrayToSort.Length];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] tmpCountingSortArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ArrayToSort.Length; i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> tmpSplitDigit = ArrayToSort[i] / (<span class="built_in">int</span>)Math.Pow(<span class="number">10</span>, k - <span class="number">1</span>) - (ArrayToSort[i] / (<span class="built_in">int</span>)Math.Pow(<span class="number">10</span>, k)) * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tmpCountingSortArray[tmpSplitDigit] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> m = <span class="number">1</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">tmpCountingSortArray[m] += tmpCountingSortArray[m -</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> n = ArrayToSort.Length - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> tmpSplitDigit = ArrayToSort[n] / (<span class="built_in">int</span>)Math.Pow(<span class="number">10</span>, k - <span class="number">1</span>) -</span><br><span class="line"></span><br><span class="line">(ArrayToSort[n] / (<span class="built_in">int</span>)Math.Pow(<span class="number">10</span>, k)) * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tmpArray[tmpCountingSortArray[tmpSplitDigit] - <span class="number">1</span>] = ArrayToSort</span><br><span class="line"></span><br><span class="line">[<span class="meta">n</span>];</span><br><span class="line"></span><br><span class="line">tmpCountingSortArray[tmpSplitDigit] -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> p = <span class="number">0</span>; p &lt; ArrayToSort.Length; p++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ArrayToSort[p] = tmpArray[p];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ArrayToSort;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] newIntArray = intArray;</span><br><span class="line"></span><br><span class="line">RadixSorter rS=<span class="keyword">new</span> RadixSorter();</span><br><span class="line"></span><br><span class="line">newIntArray = rS.RadixSort(intArray, intArray.Length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> intArray)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Merge</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F; 要求: &#x2F;&#x2F;&#x2F; arrayToSort的元素必须大于等于0。或者经过一定的转换使其元素在 &#x2F;&#x2F;&#x2F; 大于等于0范围内。比如有例如以下序列(-1,-8,10,11),那么依据最小值8, &#x2F;&#x2F;&#x2F; 将各个数字加8转化为(7,0,18,19),然后进行计数排序。结果为(0,7,18,19), &#x2F;&#x2F;&#x2F; 然后再将结果个数字减8即为(-8,-1,10,11) &#x2F;&#x2F;&#x2F; </summary> &#x2F;&#x2F;&#x2F; <param name="arrayToSort">要排序的数组</param> &#x2F;&#x2F;&#x2F; <param name="maxValue">数组的最大值加一</param> &#x2F;&#x2F;&#x2F; <returns>计数排序后的结果</returns> public static int[] CountingSort(int[] arrayToSort, int k) { &#x2F;&#x2F; 排序后的结果存储 int[] sortedArray &#x3D; new int[arrayToSort.Length]; &#x2F;&#x2F; 计数数组 int[] countingArray &#x3D; new int[k]; &#x2F;&#x2F; 计数数组初始化 for (int i &#x3D; 0; i &lt; countingArray.Length; i++) { countingArray[i] &#x3D; 0; } &#x2F;&#x2F; 单个元素计数(经过该步骤countingArray[i]的含义为数字i的个数为countingArray[i]) for (int i &#x3D; 0; i &lt; arrayToSort.Length; i++) { countingArray[arrayToSort[i]] &#x3D; countingArray[arrayToSort[i]] + 1; } &#x2F;&#x2F; 计算小于等于某数的个数(经过该步骤countingArray[i]的含义为小于等于数字i的元素个数为countingArray[i]) for (int i &#x3D; 1; i &lt; countingArray.Length; i++) { countingArray[i] +&#x3D; countingArray[i - 1]; } &#x2F;&#x2F; 得到排序后的结果 for (int i &#x3D; 0; i &lt; sortedArray.Length; i++) { int numIndex &#x3D; countingArray[arrayToSort[i]] - 1; sortedArray[numIndex] &#x3D; arrayToSort[i]; countingArray[arrayToSort[i]] &#x3D; countingArray[arrayToSort[i]] - 1; } return sortedArray; } static void Main(string[] args) { int[] intArray &#x3D; new int[] { 5, 3, 7, 4, 8, 2, 9, 1, 0, 6 }; int[] intNewArray &#x3D; intArray; intNewArray &#x3D; CountingSort(intArray, intArray.Length); foreach (int i in intNewArray) { Console.Write(i + “ “); } Console.ReadKey(); } } }</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Merge</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSortFunction</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">BuildMaxHeap(array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = array.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Swap(<span class="keyword">ref</span> array[<span class="number">0</span>], <span class="keyword">ref</span> array[i]);</span><br><span class="line"></span><br><span class="line">MaxHeapify(array, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.Write(ex.Message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildMaxHeap</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = array.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MaxHeapify(array, i, array.Length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.Write(ex.Message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaxHeapify</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> currentIndex, <span class="built_in">int</span> heapSize</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> left = <span class="number">2</span> * currentIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> right = <span class="number">2</span> * currentIndex + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> large = currentIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[large])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">large = left;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[large])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">large = right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentIndex != large)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Swap(<span class="keyword">ref</span> array[currentIndex], <span class="keyword">ref</span> array[large]);</span><br><span class="line"></span><br><span class="line">MaxHeapify(array, large, heapSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.Write(ex.Message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">temp = a;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">HeapSortFunction(intArray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> intArray)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序的分类-稳定性-时间复杂度和空间复杂度总结"><a href="#排序的分类-稳定性-时间复杂度和空间复杂度总结" class="headerlink" title="排序的分类&#x2F;稳定性&#x2F;时间复杂度和空间复杂度总结"></a>排序的分类&#x2F;稳定性&#x2F;时间复杂度和空间复杂度总结</h3><img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/CSharp%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/IMG-20250704185625088.png" class="">  

<p>版权声明：本文博客原创文章。博客，未经同意，不得转载。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序算法CSharp实现</title>
    <url>/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="冒泡排序算法（C-实现）-Eric-Sun-博客园"><a href="#冒泡排序算法（C-实现）-Eric-Sun-博客园" class="headerlink" title="冒泡排序算法（C#实现） - Eric Sun - 博客园"></a>冒泡排序算法（C#实现） - Eric Sun - 博客园</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>简单的冒泡排序算法，代码如下：&#x2F;&#x2F;冒泡排序（从数组的起始位置开始遍历，以大数为基准：大的数向下沉一位）privatestaticvoid BubbleSortFunction(int[] array) { try { int length &#x3D; array.Length; int temp; bool</p>
</blockquote>
<hr>
<p>简单的冒泡排序算法，代码如下：</p>
<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625090.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冒泡排序（从数组的起始位置开始遍历，以大数为基准：大的数向下沉一位）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; BubbleSortFunction(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array.Length;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; hasExchangeAction; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录此次大循环中相邻的两个数是否发生过互换（如果没有互换，则数组已经是有序的）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; length &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组有N个数，那么用N-1次大循环就可以排完&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    hasExchangeAction &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次大循环都假设数组有序&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; j &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; length &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; j&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从数组下标0处开始遍历，（length - i - 1 是刨除已经排好的大数）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#123;&lt;br&gt;                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (array[j] &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; array[j &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相邻两个数进行比较，如果前面的数大于后面的数，则将这相邻的两个数进行互换&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        &#123;&lt;br&gt;                            temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[j];&lt;br&gt;                            array[j] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[j &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];&lt;br&gt;                            array[j &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; temp;&lt;br&gt;                            hasExchangeAction &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发生过互换&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        &#125;&lt;br&gt;                    &#125;&lt;br&gt;&lt;br&gt;                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;hasExchangeAction) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有发生过互换，则数组已经是有序的了，跳出循环&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#123;&lt;br&gt;                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;br&gt;                    &#125;&lt;br&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625090.gif" class="" title="复制代码">

<p>。。。。。</p>
<p>posted @ 2011-08-17 16:02  <a href="https://www.cnblogs.com/mingmingruyuedlut">Eric Sun</a>  阅读(7637)  评论()  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=2143231">编辑</a>  收藏  举报</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序算法CSharp实现</title>
    <url>/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="堆排序算法（C-实现）"><a href="#堆排序算法（C-实现）" class="headerlink" title="堆排序算法（C#实现）"></a>堆排序算法（C#实现）</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>在软件设计相关领域，“堆（Heap）”的概念主要涉及到两个方面：一种是数据结构，逻辑上是一颗完全二叉树，存储上是一个数组对象（二叉堆）。另一种是垃圾收集存储区，是软件系统可以编程的内存区域。本文所说的堆指的是前者，另外，这篇文章中堆中元素的值均以整形为例堆排序的时间复杂度是O(nlog2n),与快速</p>
</blockquote>
<hr>
<p>在软件设计相关领域，“堆（Heap）”的概念主要涉及到两个方面：</p>
<p>一种是数据结构，逻辑上是一颗完全二叉树，存储上是一个数组对象（二叉堆）。</p>
<p>另一种是垃圾收集存储区，是软件系统可以编程的内存区域。</p>
<p>本文所说的堆指的是前者，另外，这篇文章中堆中元素的值均以整形为例</p>
<p>堆排序的时间复杂度是O(nlog2n),与快速排序达到相同的时间复杂度. 但是在实际应用中,我们往往采用快速排序而不是堆排序. 这是因为快速排序的一个好的实现,往往比堆排序具有更好的表现. 堆排序的主要用途,是在形成和处理优先级队列方面. 另外, 如果计算要求是类优先级队列(比如, 只要返回最大或者最小元素, 只有有限的插入要求等), 堆同样是很适合的数据结构.</p>
<p>**堆排序<br>**堆排序是一种选择排序。是不稳定的排序方法。时间复杂度为O(nlog2n)。<br>堆排序的特点是：在排序过程中，将排序数组看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或最小)的记录。</p>
<p><strong>基本思想</strong><br>1.将要排序的数组创建为一个大根堆。大根堆的堆顶元素就是这个堆中最大的元素。<br>2.将大根堆的堆顶元素和无序区最后一个元素交换，并将无序区最后一个位置例入有序区，然后将新的无序区调整为大根堆。<br>重复操作，无序区在递减，有序区在递增。<br>初始时，整个数组为无序区，第一次交换后无序区减一，有序区增一。<br>每一次交换，都是大根堆的堆顶元素插入有序区，所以有序区保持是有序的。</p>
<p><strong>大根堆和小根堆</strong><br>堆：是一颗完全二叉树。<br>大根堆：所有节点的子节点比其自身小的堆<br>小根堆：所有节点的子节点比其自身大的堆</p>
<p><strong>堆与数组的关系</strong></p>
<p>堆是一种逻辑结构（形象的表示数据的存储格式），数组则是数据的实际存储结构（对应数据的存储地址），堆中的根节点与左右子节点在存储数组中的位置关系如下：假设根节点在数组中的位置（数组下标）为 i ，那么左节点在数组中的位置（数组下标）为 i * 2 + 1 ， 右节点在数组中的位置（数组下标）为 i * 2 + 2 。</p>
<p>以上是基本的知识点，具体代码如下所示：</p>
<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625091.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;堆排序算法（传递待排数组名，即：数组的地址。故形参数组的各种操作反应到实参数组上）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　 private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; HeapSortFunction(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                BuildMaxHeap(array);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建大顶推（初始状态看做：整体无序）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array.Length &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;)&lt;br&gt;                &#123;&lt;br&gt;                    Swap(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; array[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;], &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; array[i]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将堆顶元素依次与无序区的最后一位交换（使堆顶元素进入有序区）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    MaxHeapify(array, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, i); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新将无序区调整为大顶堆&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;br&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建大顶推（根节点大于左右子节点）&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;array&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待排数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　 private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; BuildMaxHeap(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据大顶堆的性质可知：数组的前半段的元素为根节点，其余元素都为叶节点&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array.Length &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从最底层的最后一个根节点开始进行大顶推的调整&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    MaxHeapify(array, i, array.Length); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整大顶堆&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;br&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 大顶推的调整过程&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;array&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待调整的数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;currentIndex&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待调整元素在数组中的位置（即：根节点）&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;heapSize&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;堆中所有元素的个数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　 private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MaxHeapify(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; heapSize)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; left &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; currentIndex &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点在数组中的位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　int&lt;/span&gt;&lt;span&gt; right &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; currentIndex &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点在数组中的位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　int&lt;/span&gt;&lt;span&gt; large &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; currentIndex;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录此根节点、左子节点、右子节点 三者中最大值的位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (left &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; heapSize &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; array[left] &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; array[large])  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与左子节点进行比较&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    large &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; left;&lt;br&gt;                &#125;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (right &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; heapSize &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; array[right] &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; array[large])    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与右子节点进行比较&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    large &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; right;&lt;br&gt;                &#125;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (currentIndex &lt;/span&gt;&lt;span&gt;!=&lt;/span&gt;&lt;span&gt; large)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果 currentIndex != large 则表明 large 发生变化（即：左右子节点中有大于根节点的情况）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    Swap(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; array[currentIndex], &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; array[large]);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将左右节点中的大者与根节点进行交换（即：实现局部大顶堆）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    MaxHeapify(array, large, heapSize); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上次调整动作的large位置（为此次调整的根节点位置），进行递归调整&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;br&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 交换函数&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;元素a&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;b&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;元素b&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Swap(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a, &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br&gt;            temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; a;&lt;br&gt;            a &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; b;&lt;br&gt;            b &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; temp;&lt;br&gt;        &#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625091.gif" class="" title="复制代码">
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序算法CSharp实现</title>
    <url>/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="归并排序算法（C-实现）"><a href="#归并排序算法（C-实现）" class="headerlink" title="归并排序算法（C#实现）"></a>归并排序算法（C#实现）</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>自顶向下的归并排序：是利用递归和分而治之的技术将数据序列划分成为越来越小的半子表，再对半子表排序，最后再用递归步骤将排好序的半子表合并成为越来越大的有序序列，归并排序包括两个步骤，分别为：1）划分子表  2）合并半子表</p>
</blockquote>
<hr>
<p>     归并排序(Merge Sort)是利用”归并”技术来进行排序。归并是指将若干个已排序的子文件合并成一个有序的文件。归并排序有两种方式：1): <strong>自底向上的方法</strong> 2):<strong>自顶向下的方法</strong></p>
<p> <strong>1、 自底向上的方法</strong><br>（1） 自底向上的基本思想<br>     自底向上的基本思想是：第1趟归并排序时，将待排序的文件R[1..n]看作是n个长度为1的有序子文件，将这些子文件两两归并，若n为偶数，则得到n&#x2F;2个长度为2的有序子文件；若n为奇数，则最后一个子文件轮空(不参与归并)。故本趟归并完成后，前n&#x2F;2 - 1个有序子文件长度为2，但最后一个子文件长度仍为1；第2趟归并则是将第1趟归并所得到的n&#x2F;2个有序的子文件两两归并，如此反复，直到最后得到一个长度为n的有序文件为止。<br>     上述的每次归并操作，均是将两个有序的子文件合并成一个有序的子文件，故称其为”二路归并排序”。类似地有k(k&gt;2)路归并排序。   </p>
<p><strong>2、自顶向下的方法(本文主要介绍此种方法，下面的文字都是对此种方法的解读)</strong></p>
<p>（1） 自顶向下的基本思想<br>     采用分治法进行自顶向下的算法设计，形式更为简洁。<br>     自顶向下的归并排序：是利用递归和分而治之的技术将数据序列划分成为越来越小的半子表，再对半子表排序，最后再用递归步骤将排好序的半子表合并成为越来越大的有序序列，归并排序包括两个步骤，分别为：</p>
<p>      1）划分子表</p>
<p>      2）合并半子表</p>
<p>（1）分治法的三个步骤<br>     设归并排序的当前区间是R[low..high]，分治法的三个步骤是：<br>①分解：将当前区间一分为二，即求分裂点<br>②求解：递归地对两个子区间R[low..mid]和R[mid+1..high]进行归并排序；<br>③组合：将已排序的两个子区间R[low..mid]和R[mid+1..high]归并为一个有序的区间R[low..high]。<br>  递归的终结条件：子区间长度为1（一个记录自然有序）。</p>
<p><strong>如下演示递归的整个过程：</strong></p>
<p>递归便是深度遍历（如下由左至右进行遍历）：假设有这样的一列数组{9,8,7,6,5,4,3,2,1}进行划分的顺序如下：</p>
<p>{9,8,7,6,5,4,3,2,1} –&gt; {9,8,7,6,5}，{4,3,2,1}</p>
<p>{9,8,7,6,5} –&gt; {9,8,7}，{6,5}</p>
<p>                        {9,8,7} –&gt; {9,8}，{7}</p>
<p>                                          {9,8} –&gt; {9}，{8}</p>
<p>                        {6,5} –&gt;{6}，{5}</p>
<p>{4,3,2,1} –&gt; {4,3}，{2,1}</p>
<p>                      {4,3} –&gt;{4}，{3}</p>
<p>                      {2,1} –&gt;{2}，{1}</p>
<p>当深度划分到左右数组都只剩1个元素的时候，进行上述逆序的合并：</p>
<p>{9}，{8} –&gt; {8,9} 然后和 {7} –&gt; {7,8,9}</p>
<p>                                {6}，{5} –&gt; {5,6}    然后 {7,8,9}和{5,6} –&gt; {5,6,7,8,9}</p>
<p>                                     {2}，{1} –&gt; {1,2}</p>
<p>                                     {4}，{3} –&gt; {3,4}   然后 {1,2}和 {3,4} –&gt; {1,2,3,4}</p>
<p>                                                                                                                         最终{5,6,7,8,9}和{1,2,3,4} –&gt; {1,2,3,4,5,6,7,8,9}</p>
<p><strong>具体实现代码如下所示：</strong></p>
<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625092.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;//&lt;/span&gt;&lt;span&gt;归并排序（目标数组，子表的起始位置，子表的终止位置）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MergeSortFunction(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; first, &lt;span&gt;int&lt;/span&gt; last)&lt;br&gt;        &#123;&lt;br&gt;            &lt;span&gt;try&lt;/span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;span&gt;if&lt;/span&gt; (first &amp;lt; last)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子表的长度大于1，则进入下面的递归处理&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &#123;&lt;br&gt;                    &lt;span&gt;int&lt;/span&gt; mid = (first + last) / &lt;span&gt;2&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子表划分的位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    MergeSortFunction(array, first, mid);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对划分出来的左侧子表进行递归划分&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    MergeSortFunction(array, mid + &lt;span&gt;1&lt;/span&gt;, last);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对划分出来的右侧子表进行递归划分&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    MergeSortCore(array, first, mid, last); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对左右子表进行有序的整合（归并排序的核心部分）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;span&gt;catch&lt;/span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;br&gt;&lt;br&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;归并排序的核心部分：将两个有序的左右子表（以mid区分），合并成一个有序的表&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MergeSortCore(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; first, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt; last)&lt;br&gt;        &#123;&lt;br&gt;            &lt;span&gt;try&lt;/span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;span&gt;int&lt;/span&gt; indexA = first; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左侧子表的起始位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &lt;span&gt;int&lt;/span&gt; indexB = mid + &lt;span&gt;1&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右侧子表的起始位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &lt;span&gt;int&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[last + &lt;span&gt;1&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明数组（暂存左右子表的所有有序数列）：长度等于左右子表的长度之和。&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &lt;span&gt;int&lt;/span&gt; tempIndex = &lt;span&gt;0&lt;/span&gt;;&lt;br&gt;                &lt;span&gt;while&lt;/span&gt; (indexA &amp;lt;= mid &amp;amp;&amp;amp; indexB &amp;lt;= last) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行左右子表的遍历，如果其中有一个子表遍历完，则跳出循环&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &#123;&lt;br&gt;                    &lt;span&gt;if&lt;/span&gt; (array[indexA] &amp;lt;= array[indexB]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时左子表的数 &amp;lt;= 右子表的数&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    &#123;&lt;br&gt;                        temp[tempIndex++] = array[indexA++];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将左子表的数放入暂存数组中，遍历左子表下标++&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    &#125;&lt;br&gt;                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时左子表的数 &amp;gt; 右子表的数&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    &#123;&lt;br&gt;                        temp[tempIndex++] = array[indexB++];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将右子表的数放入暂存数组中，遍历右子表下标++&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                    &#125;&lt;br&gt;                &#125;&lt;br&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有一侧子表遍历完后，跳出循环，将另外一侧子表剩下的数一次放入暂存数组中（有序）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                &lt;span&gt;while&lt;/span&gt; (indexA &amp;lt;= mid)&lt;br&gt;                &#123;&lt;br&gt;                    temp[tempIndex++] = array[indexA++];&lt;br&gt;                &#125;&lt;br&gt;                &lt;span&gt;while&lt;/span&gt; (indexB &amp;lt;= last)&lt;br&gt;                &#123;&lt;br&gt;                    temp[tempIndex++] = array[indexB++];&lt;br&gt;                &#125;&lt;br&gt;&lt;br&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将暂存数组中有序的数列写入目标数组的制定位置，使进行归并的数组段有序&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;                tempIndex = &lt;span&gt;0&lt;/span&gt;;&lt;br&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = first; i &amp;lt;= last; i++)&lt;br&gt;                &#123;&lt;br&gt;                    array[i] = temp[tempIndex++];&lt;br&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;span&gt;catch&lt;/span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625092.gif" class="" title="复制代码">

<p>       对于N个元素的数组来说, 如此划分需要的层数是以2为底N的对数, 每一层中, 每一个元素都要复制到结果数组中, 并复制回来, 所以复制2N次, 那么对于归并排序,它的时间复杂度为O(N*logN), 而比较次数会少得多, 最少需要N&#x2F;2次,最多为N-1次, 所以平均比较次数在两者之间. 它的主要问题还是在于在内存中需要双倍的空间.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序算法CSharp实现</title>
    <url>/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="插入排序算法C-实现"><a href="#插入排序算法C-实现" class="headerlink" title="插入排序算法C#实现"></a>插入排序算法C#实现</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>插入排序算法主要分为：直接插入算法，折半排序算法（二分插入算法），希尔排序算法，后两种是直接插入算法的改良。因此直接插入算法是基础，这里先进行直接插入算法的分析与编码。直接插入算法的排序思想：假设有序数组从小到大为array[0],array[1],array[2],….,array[n-2],</p>
</blockquote>
<hr>
<p>插入排序算法主要分为：直接插入算法，折半排序算法（二分插入算法），希尔排序算法，后两种是直接插入算法的改良。因此直接插入算法是基础，这里先进行直接插入算法的分析与编码。</p>
<p>直接插入算法的排序思想：假设有序数组从小到大为array[0],array[1],array[2],….,array[n-2],array[n-1]，那么将待排数值array[n]与前面的有序数组从后向前依次比较，直到在有序数组中找到小于待排数值array[n]的位置，将array[n]插入到此位置，并入组合成新的有序数组。</p>
<p><strong>直接插入算法</strong>--代码如下所示：</p>
<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625093.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;　　　　　//&lt;/span&gt;&lt;span&gt;直接插入排序算法（传递待排数组名，即：数组的地址。故形参数组的各种操作反应到实参数组上）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; InsertSortionFunction(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;临时变量，存储待排的数值&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; array.Length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将无序的所有数值依次插入到有序数组中，注：下标从1开始，因为操作的是同一个数组&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[i];    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录待插入前面有序数组的数值&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　 int&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录前方有序数组的末尾位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　 while&lt;/span&gt;&lt;span&gt; (index &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; array[index] &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; temp)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历前面的有序数组，并且从大到小依次与待排数值进行比较&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#123;&lt;br&gt;                        array[index &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[index];    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果index&amp;gt;=0并且此时的值大于待排数值，将此处的值向后移动一位&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        index&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index--向前遍历有序数组&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#125;&lt;br&gt;                    array[index &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; temp;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于前面的index--，所以temp插入的位置是index+1&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625093.gif" class="" title="复制代码">

<p>折半排序算法是对直接插入算法的一种优化，优化的核心是：通过折半查看有序数组中间位置的数值（a）与待插入的数值（temp）的大小，如果a&gt;&#x3D;temp，则转向折半的左区间继续折半查找； 如果a&lt;temp，则转向折半后的右区间继续折半查找。直到左右下标相同时，此时折半的下标也指向相同的位置，再做最后一次循环，最终的结果是：左右下标相差1，并且原来左侧的下标指向大于temp的位置，原来右侧的下标指向了小于temp的位置，即：array[biggerIndex] &lt; temp &lt; array[smallerIndex]。</p>
<p><strong>折半排序算法</strong>--代码如下：</p>
<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625093.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;  &amp;nbsp;　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;折半排序算法（传递待排数组名，即：数组的地址。故形参数组的各种操作反应到实参数组上）&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;        private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; BinaryInsertionSortFunction(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; smallerIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录有序数组的起始位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　 int&lt;/span&gt;&lt;span&gt; biggerIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录有序数组的终止位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　 int&lt;/span&gt;&lt;span&gt; midIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录获取有序数组的中间位置（折半法的关键：折半的位置）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　 int&lt;/span&gt;&lt;span&gt; temp;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录带排的数值&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　 for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; array.Length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环向有序数组中插入数值（i从1开始，因为操作的是同一个数组）&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[i];   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录待插入有序数组的数值&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    biggerIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br&gt;                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当smallerIndex==biggerIndex时，进入最后一次循环：smallerIndex指向大于temp的数组位置，biggerIndex指向小于temp的数组位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　 while&lt;/span&gt;&lt;span&gt; (smallerIndex &lt;/span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;span&gt; biggerIndex)   &lt;br&gt;                    &#123;&lt;br&gt;                        midIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; (smallerIndex &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; biggerIndex) &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定折半的位置&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　　　if&lt;/span&gt;&lt;span&gt;(array[midIndex] &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; temp)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;折半位置的数值 &amp;gt;= temp&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        &#123;&lt;br&gt;                            biggerIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; midIndex &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;biggerIndex以midIndex为基础向前移动一位&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        &#125;&lt;br&gt;                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;&lt;br&gt;                        &#123;&lt;br&gt;                            smallerIndex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; midIndex &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;smallerIndex以midIndex为基础向后移动一位&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        &#125;&lt;br&gt;                    &#125;&lt;br&gt;                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; j &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;biggerIndex; j&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将有序数组中大于temp的数值分别向后移动一位&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#123;&lt;br&gt;                        array[j &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[j];  &lt;/span&gt;&lt;span&gt;//&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#125;&lt;br&gt;                    array[biggerIndex &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; temp;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将temp插入biggerIndex + 1，因为此时array[biggerIndex]&amp;lt;temp&amp;lt;array[smallerIndex]&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625093.gif" class="" title="复制代码">

<p>希尔排序同样是直接插入排序算法的一种改进，基本思想是：将无序的数列划分为若干小的子序列，然后对子序列进行直接插入排序。<br>时间性能优于直接插入排序算法，但是一种不稳定的排序，时间复杂度为O(nlogn)。<br>希尔排序算法主要分为3重循环：<br>第一重循环–&gt;按照gap的大小进行分组，初始化从array.Length&#x2F;2开始，依次递减到1<br>第二重循环–&gt;对所有分组进行排序<br>第三重循环–&gt;组内进行直接插入排序</p>
<p><strong>希尔排序算法</strong>--代码如下：</p>
<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625093.gif" class="" title="复制代码">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;　　　　  private &lt;/span&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ShellSortFunction(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array)&lt;br&gt;        &#123;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;&lt;br&gt;            &#123;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array.Length;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br&gt;                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; gap &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; length &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;; gap &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; gap&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一重循环，按照gap的大小进行分组&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                &#123;&lt;br&gt;                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; gap; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二重循环，对所有分组进行排序&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                    &#123;&lt;br&gt;                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; i; j &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; length; j &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; j &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; gap)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三重循环，组内进行直接插入排序&lt;/span&gt;&lt;span&gt;&lt;br&gt;&lt;/span&gt;&lt;span&gt;                        &#123;&lt;br&gt;                            temp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[j];&lt;br&gt;                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; j &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; gap;&lt;br&gt;                            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (index &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; array[index] &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; temp)&lt;br&gt;                            &#123;&lt;br&gt;                                array[index &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; gap] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array[index];&lt;br&gt;                                index &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; gap;&lt;br&gt;                            &#125;&lt;br&gt;                            array[index &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; gap] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; temp;&lt;br&gt;                        &#125;&lt;br&gt;                    &#125;&lt;br&gt;                &#125;&lt;br&gt;            &#125;&lt;br&gt;            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)&lt;br&gt;            &#123; &#125;&lt;br&gt;        &#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95CSharp%E5%AE%9E%E7%8E%B0/IMG-20250704185625093.gif" class="" title="复制代码">

<p>。。。。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2019/11/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2019/11/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2019/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2015/11/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在软件开发中，<strong>单例模式（Singleton Pattern）</strong> 是一种常见的设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。它适用于需要严格控制资源访问的场景，例如数据库连接池、配置管理器或任务调度器等。本文将详细介绍单例模式的核心思想，并展示其在 <strong>C#、Python、Golang、C 和 C++</strong> 中的实现方式。</p>
<p>单例模式的主要特点包括：</p>
<ul>
<li><strong>唯一性</strong>：类只有一个实例对象</li>
<li><strong>自创建</strong>：类自行创建自己的实例</li>
<li><strong>全局访问</strong>：提供一个全局访问点来获取该实例</li>
</ul>
<p>特点</p>
<ul>
<li><strong>唯一性</strong>：类自身负责创建和管理实例。</li>
<li><strong>延迟加载</strong>：实例通常在第一次使用时创建（懒汉式）。</li>
<li><strong>线程安全</strong>：在多线程环境中需确保实例的唯一性。</li>
<li><strong>不可克隆&#x2F;序列化</strong>：避免通过克隆或反序列化创建新实例。</li>
</ul>
<h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C# 实现"></a>C# 实现</h3><p>C# 中的单例模式通常通过 <strong>双重检查锁定（Double-Check Locking）</strong> 实现，以确保线程安全和延迟加载。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 保证多线程下的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton _instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="comment">// 第一次检查，避免不必要的锁定</span></span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			 <span class="comment">// 锁定操作</span></span><br><span class="line">            <span class="keyword">lock</span> (_lock)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">// 第二次检查，确保多线程安全</span></span><br><span class="line">                <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="饿汉式（立即加载）"><a href="#饿汉式（立即加载）" class="headerlink" title="饿汉式（立即加载）"></a>饿汉式（立即加载）</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 静态初始化，CLR保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>Python 的模块天然支持单例，但也可以通过类实现。以下是一个线程安全的懒汉式实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    _instance_lock = threading.Lock()  <span class="comment"># 线程锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化逻辑</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> cls._instance_lock:  <span class="comment"># 确保线程安全</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    Singleton._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">is</span> s2)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure>

<h4 id="饿汉式（模块级单例）"><a href="#饿汉式（模块级单例）" class="headerlink" title="饿汉式（模块级单例）"></a>饿汉式（模块级单例）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># singleton.py</span><br><span class="line">class Singleton:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = Singleton()</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">from singleton import instance</span><br></pre></td></tr></table></figure>

<h4 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a>装饰器实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>): </span><br><span class="line">	instances = &#123;&#125; </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>): </span><br><span class="line">		<span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances: </span><br><span class="line">			instances[cls] = cls(*args, **kwargs) </span><br><span class="line">			<span class="keyword">return</span> instances[cls]</span><br><span class="line">		<span class="keyword">return</span> wrapper </span><br><span class="line">		</span><br><span class="line"><span class="meta">@singleton </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>: </span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance *Singleton</span><br><span class="line">	once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	<span class="comment">// sync.Once 确保代码只执行一次，线程安全</span></span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		instance = &amp;Singleton&#123;&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := GetInstance()</span><br><span class="line">	s2 := GetInstance()</span><br><span class="line">	<span class="built_in">println</span>(s1 == s2) <span class="comment">// 输出: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Singleton struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">var instance = &amp;Singleton&#123;&#125;</span><br><span class="line"></span><br><span class="line">func GetInstance() *Singleton &#123;</span><br><span class="line">	return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>控制实例数量</strong>：确保全局唯一性，避免资源浪费。</li>
<li><strong>灵活扩展</strong>：可通过子类化或组合模式扩展功能。</li>
<li><strong>全局访问</strong>：简化了对共享资源的访问。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>违反单一职责原则</strong>：类负责管理自己的实例，增加了耦合。</li>
<li><strong>测试困难</strong>：全局状态可能导致单元测试难以隔离。</li>
<li><strong>生命周期管理</strong>：实例与程序生命周期一致，可能占用过多内存。.</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>资源管理器</strong>：如文件系统、数据库连接池。</li>
<li><strong>配置中心</strong>：全局配置对象，避免重复加载配置。</li>
<li><strong>缓存服务</strong>：单点缓存，减少内存开销。</li>
<li><strong>日志记录器</strong>：统一日志输出，避免多线程冲突。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式是一种简单但强大的设计模式，适用于需要严格控制实例数量的场景。不同编程语言的实现方式各有特色：</p>
<ul>
<li><strong>C#</strong> 通过 <code>lock</code> 和 <code>volatile</code> 保证线程安全。</li>
<li><strong>Python</strong> 可利用模块的天然单例特性。</li>
<li><strong>Golang</strong> 使用 <code>sync.Once</code> 实现原子初始化。</li>
<li><strong>C&#x2F;C++</strong> 通过静态局部变量或互斥锁实现线程安全。</li>
</ul>
<p><strong>实现要点总结</strong>：</p>
<ol>
<li><strong>私有构造函数</strong>：防止外部直接实例化</li>
<li><strong>静态实例变量</strong>：保存唯一的实例</li>
<li><strong>全局访问点</strong>：提供获取实例的静态方法</li>
<li><strong>线程安全</strong>：在多线程环境下需要考虑线程安全问题</li>
</ol>
<p><strong>选择建议</strong>：</p>
<ul>
<li><strong>懒汉式</strong>：适用于实例创建开销较大，且可能不被使用的场景</li>
<li><strong>饿汉式</strong>：适用于实例创建开销小，且一定会被使用的场景</li>
<li><strong>双重检查锁定</strong>：适用于需要兼顾性能和线程安全的场景</li>
</ul>
<p>在实际开发中，需根据语言特性和具体需求选择合适的实现方式，同时注意避免过度使用单例模式，以免引入全局状态带来的复杂性。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2019/11/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2019/11/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2019/11/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2019/11/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2019/11/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂方法</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2019/11/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2019/11/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2019/11/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法</title>
    <url>/2019/11/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2019/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2019/11/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2019/11/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2019/11/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2019/11/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2019/11/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列导航</title>
    <url>/2019/11/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<a href="/2019/11/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="面向对象的设计原则">面向对象的设计原则</a>
<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p>创建型模式抽象了实例化的过程。创建性模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建性模式在创建了什么、谁创建它、她是怎么被创建的、以及何时创建方面提供了灵活性。创建相应数目的原型并克隆她们通常比每次用适合的状态手工实例化该类更方便。</p>
<a href="/2015/11/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a> (Singleton) 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

<p><strong>优点</strong>：对唯一实例的受控访问。</p>
<p><strong>缺点</strong>：饿汉式&#x2F;懒汉式  多线程同时访问时可能造成多个实例。</p>
<a href="/2019/11/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="工厂方法模式">工厂方法模式</a> (Factory Method) 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

<p><strong>优点</strong>：是简单工厂模式的进一步抽象和推广，既保持了简单工厂模式的优点（工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖），而且克服了简单工厂的缺点（违背了开放封闭原则）。</p>
<p><strong>缺点</strong>：每增加一个产品，就需要增加一个产品工厂的类，增加了额外的开发。（用反射可以解决）。</p>
<a href="/2019/11/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式">抽象工厂模式</a> (Abstract Factory) 提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。

<p><strong>优点</strong>：</p>
<p>a)   改变具体工厂即可使用不同的产品配置，使改变一个应用的具体工厂变得很容易。</p>
<p>b)   让具体的创建实例过程与客户端分离，客户端通过抽象接口操作实例，产品的具体类名也被具体工厂的实现分离。</p>
<p><strong>缺点</strong>：如果要新增方法，改动极大。</p>
<a href="/2019/11/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" title="建造者模式">建造者模式</a> (Builder) 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

<p><strong>优点</strong>：使得建造代码与表示代码分离。</p>
<p><strong>缺点</strong>：1、增加代码量；2、Builder只是一个替代构造器的选择，不能直接用于降低非构造函数方法的参数数量。</p>
<a href="/2019/11/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="原型模式">原型模式</a> (Prototype) 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

<p><strong>优点</strong>：隐藏了对象创建的细节，大大提升了性能。不用重新初始化对象，而是动态的获得对象运行时的状态。</p>
<p><strong>缺点</strong>：深复制 or 浅复制 。</p>
<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><a href="/2019/11/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="适配器模式">适配器模式</a> (Adapter) 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

<p>在GoF的设计模式中，适配器有两种类型，类适配器模式和对象适配器模式。</p>
<p>a)   类适配器模式：通过多重继承对一个接口与另一个接口进行匹配，而C#，Java等语言都不支持多重继承，也就是一个类只有一个父类。</p>
<p>b)   一般都指的是 对象适配器模式</p>
<p><strong>优点</strong>：能够复用现存的类，客户端统一调用同一接口，更简单、直接、紧凑。</p>
<p><strong>缺点</strong>：适配器模式有点儿“亡羊补牢”的感觉，设计阶段要避免使用。</p>
<a href="/2019/11/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="桥接模式">桥接模式</a> (Bridge) 将抽象部分与它的实现部分分离，使它们都可以独立的变化。

<p><strong>优点</strong>：减少各部分的耦合。 分离抽象和实现部分，更好的扩展性，可动态地切换实现、可减少子类的个数。</p>
<p><strong>缺点</strong>：1、<a href="https://so.csdn.net/so/search?q=%E6%A1%A5%E6%8E%A5&spm=1001.2101.3001.7020">桥接</a>模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 2、桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性</p>
<a href="/2019/11/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" title="装饰模式">装饰模式</a> (Decorator) 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活。

<p><strong>优点</strong>：把类中的装饰功能从类中搬移出去，简化原有的类。有效的把类的核心职责和装饰功能区分开，去除相关类中重复的装饰逻辑。</p>
<p><strong>缺点</strong>：利用装饰器模式,常常造成设计中有大量的小类,数量实在太多,可能会造成使用此API程序员的困扰。</p>
<a href="/2019/11/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" title="组合模式">组合模式</a> (Composite) 将对象组合成树形结构以表示“部分-整体”的层次结构。

<p><strong>优点</strong>：组合模式让客户可以一致的使用组合结构和单个对象。</p>
<p><strong>缺点</strong>：使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</p>
<a href="/2019/11/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" title="外观模式">外观模式</a> (Facade) 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

<p><strong>优点</strong>：1、客户对子系统的使用变得简单了，减少了与子系统的关联对象，实现了子系统与客户之间的松耦合关系。 2、只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类 3、降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程。</p>
<p><strong>缺点</strong>：1、不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性   2、在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<a href="/2019/11/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" title="享元模式">享元模式</a> (Flyweight) 运用共享技术有效的支持大量细粒度的对象。

<p><strong>优点</strong>：享元模式可以避免大量非常相似类的开销。程序中，大量细粒度的类实例来表示数据，如果它们除了几个参数外基本相同，那么把它们转移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度减少单个实例的数目。</p>
<p><strong>缺点</strong>：1、由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。2、为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</p>
<a href="/2019/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式">代理模式</a> (Proxy) 为其他对象提供一种代理以控制对这个对象的访问。

<p><strong>优点</strong>：1）代理模式能将代理对象与真正被调用的对象分离，在一定程度上降低了系统的耦合度。2）代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用。代理对象也可以对目标对象调用之前进行其他操作。</p>
<p><strong>缺点</strong>：1）在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。2）增加了系统的复杂度。</p>
<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><a href="/2019/11/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/" title="模板方法">模板方法</a> (Template Method)  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

<p><strong>优点</strong>：模板方法模式是通过把不变行为搬移到超类，去除子类中重复代码来实现它的优势，提供了一个代码复用平台，帮助子类摆脱重复的不变行为的纠缠。</p>
<p><strong>缺点</strong>：如果父类中可变的基本方法太多,将会导致类的个数增加,系统更加庞大。</p>
<a href="/2019/11/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" title="命令模式">命令模式</a> (Command) 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
<p><strong>优点</strong>：</p>
<p>a)      命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</p>
<p>b)      它能较容易的设计一个命令队列。</p>
<p>c)       在需要的情况下，可以较容易的将命令记入日志。</p>
<p>d)      允许接收请求的一方决定是否要否决请求。</p>
<p>e)      可以容易的实现对请求的撤销和重做。</p>
<p>f)        由于加进新的具体命令类不影响其他类，因此增加新的具体命令类很容易。</p>
<p><strong>缺点</strong>：会增加系统的复杂性，这里的复杂性应该主要指的是类的数量。</p>
<a href="/2019/11/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="迭代器模式">迭代器模式</a> (Iterator) 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

<p><strong>优点</strong>：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器来负责，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明的访问集合内部的数据。</p>
<p><strong>缺点</strong>：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<a href="/2019/11/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" title="观察者模式">观察者模式</a> (Publish/Subscribe) 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，让它们能够自动更新自己。

<p><strong>优点</strong>：解耦。</p>
<p><strong>缺点</strong>：如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。</p>
<a href="/2019/11/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" title="中介者模式">中介者模式</a> (mediator) 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。

<p><strong>优点</strong>：</p>
<p>a)   抽象中介者类（Mediator）减少了抽象同事类（colleague）之间的耦合，是的可以独立的改变和复用各个类。</p>
<p>b)   由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</p>
<p><strong>缺点</strong>：控制集中化导致了中介者的复杂化。</p>
<a href="/2019/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" title="状态模式">状态模式</a> (State)  当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。

<p><strong>优点</strong>：状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。【消除庞大的条件分支语句】。</p>
<p><strong>缺点</strong>：违背开放-封闭原则</p>
<a href="/2019/11/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="策略模式">策略模式</a> (strategy) 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。

<p><strong>优点</strong>：策略模式的策略类为上下文定义了一系列可供重用的算法或行为，继承有助于析取出这些算法中的公共功能。另外，策略模式简化了单元测试，因为每一个算法都有自己的类，可以通过自己的接口单独测试。当不同的行为堆砌在一个类中，很难避免使用switch语句。但是将这些行为封装在一个一个独立的策略类中，可以在使用这些行为的类中消除条件语句</p>
<p><strong>缺点</strong>：基本的策略模式，选择权在客户端，具体实现转给策略模式的上下文对象。这并不好。使用策略模式和工厂类结合，可以减轻客户端的职责。但是还是不够完美，使用反射才能真正快乐。</p>
<a href="/2019/11/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" title="责任链模式">责任链模式</a> (chain of responsibility) 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

<p><strong>优点</strong>：使得接收者和发送者都没有对方的明确信息，且链中对象自己也不知道链结构，结果是职责链可以简化对象的相互连接，它们只需要保持一个指向其后继者的引用，而不需要保持它所有的候选接收者的引用。<strong>开发者可以随时的增加或者修改处理一个请求的结构，增强了给对象指派职责的灵活性</strong>。</p>
<p><strong>缺点</strong>：一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。</p>
<a href="/2019/11/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" title="访问者模式">访问者模式</a> (Vistor) 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

<p><strong>优点</strong>：增加新的操作很容易。新的操作就是新的访问者。</p>
<p><strong>缺点</strong>：很难增加新的数据结构。</p>
<a href="/2019/11/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" title="备忘录模式">备忘录模式</a> (Memento) 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

<p><strong>优点</strong>：使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</p>
<p><strong>缺点</strong>：如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</p>
<a href="/2019/11/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="解释器模式">解释器模式</a> (interpreter) 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

<p><strong>优点</strong>：解释器很容易改变和扩展文法，因为该模式使用类来表示文法规则，可以使用继承来改变或扩展文法，也比较容易实现文法。因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。</p>
<p><strong>缺点</strong>：解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护，建议当文法非常复杂时，使用其他技术（语法分析程序、编译器生成器）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2019/11/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2019/11/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2019/11/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2019/11/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的设计原则</title>
    <url>/2019/11/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><p>写代码也是有原则的，我们之所以使用设计模式，主要是为了适应变化，提高代码复用率，使软件更具有可维护性和可扩展性。如果我们能更好的理解这些设计原则，对我们理解面向对象的设计模式也是有帮助的，因为这些模式的产生是基于这些原则的。这些规则是：单一职责原则（SRP）、开放封闭原则（OCP）、里氏代替原则（LSP）、依赖倒置原则（DIP）、接口隔离原则（ISP）、合成复用原则（CRP）和迪米特原则（LoD）。下面我们就分别介绍这几种设计原则。</p>
<ol>
<li><p><strong>单一职责原则(SRP)：</strong></p>
<ol>
<li>SRP(Single Responsibilities Principle)的定义：就一个类而言，应该仅有一个引起它变化的原因。简而言之，就是功能要单一。</li>
<li>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。(敏捷软件开发)</li>
<li>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</li>
</ol>
<p>  小结：单一职责原则（SRP）可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，引起它变化的原因就越多，这样就会导致职责依赖，大大损伤其内聚性和耦合度。</p>
</li>
<li><p><strong>开放关闭原则(OCP)</strong></p>
<ol>
<li>OCP(Open-Close Principle)的定义：就是说软件实体(类，方法等等)应该可以扩展（扩展可以理解为增加），但是不能在原来的方法或者类上修改，也可以这样说，对增加代码开放，对修改代码关闭。</li>
<li>OCP的两个特征： 对于扩展（增加）是开放的，因为它不影响原来的，这是新增加的。对于修改是封闭的，如果总是修改，逻辑会越来越复杂。</li>
</ol>
<p>  小结：开放封闭原则（OCP）是面向对象设计的核心思想。遵循这个原则可以为我们面向对象的设计带来巨大的好处：可维护（维护成本小，做管理简单，影响最小）、可扩展（有新需求，增加就好）、可复用（不耦合，可以使用以前代码）、灵活性好（维护方便、简单）。开发人员应该仅对程序中出现频繁变化的那些部分做出抽象，但是不能过激，对应用程序中的每个部分都刻意地进行抽象同样也不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
</li>
<li><p><strong>里氏代替原则(LSP)</strong></p>
<ol>
<li>LSP(Liskov Substitution Principle)的定义：子类型必须能够替换掉它们的父类型。更直白的说，LSP是实现面向接口编程的基础。</li>
</ol>
<p>  小结：任何基类可以出现的地方，子类一定可以出现，所以我们可以实现面向接口编程。 LSP是继承复用的基石，只有当子类可以替换掉基类，软件的功能不受到影响时，基类才能真正被复用，而子类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
</li>
<li><p><strong>依赖倒置原则（DIP）</strong></p>
<ol>
<li>DIP(Dependence Inversion Principle)的定义：抽象不应该依赖细节，细节应该依赖于抽象。简单说就是，我们要针对接口编程，而不要针对实现编程。</li>
<li>高层模块不应该依赖低层模块，两个都应该依赖抽象，因为抽象是稳定的。抽象不应该依赖具体（细节），具体（细节）应该依赖抽象。</li>
</ol>
<p>  小结：依赖倒置原则其实可以说是面向对象设计的标志，如果在我们编码的时候考虑的是面向接口编程，而不是简单的功能实现，体现了抽象的稳定性，只有这样才符合面向对象的设计。</p>
</li>
<li><p><strong>接口隔离原则（ISP）</strong></p>
<ol>
<li>接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。</li>
<li>使用多个专门的接口比使用单一的总接口要好。</li>
<li>一个类对另外一个类的依赖性应当是建立在最小的接口上的。</li>
<li>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</li>
<li>“不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。</li>
</ol>
<p>  小结：接口隔离原则（ISP）告诉我们，在做接口设计的时候，要尽量设计的接口功能单一，功能单一，使它变化的因素就少，这样就更稳定，其实这体现了高内聚，低耦合的原则，这样做也避免接口的污染。</p>
</li>
<li><p><strong>组合复用原则（CRP）</strong></p>
<ol>
<li>组合复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成&#x2F;聚合，尽量不要使用继承。</li>
<li>要使用好组合复用原则，首先需要区分”Has—A”和“Is—A”的关系。 “Is—A”是指一个类是另一个类的“一种”，是属于的关系，而“Has—A”则不同，它表示某一个角色具有某一项责任。导致错误的使用继承而不是聚合的常见的原因是错误地把“Has—A”当成“Is—A”.例如：鸡是动物，这就是“Is-A”的表现，某人有一个手枪，People类型里面包含一个Gun类型，这就是“Has-A”的表现。</li>
</ol>
<p>  小结：组合&#x2F;聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合&#x2F;聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏替换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>
</li>
<li><p><strong>迪米特法则（Law of Demeter）</strong></p>
<ol>
<li>迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。</li>
<li>关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。</li>
<li>外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</li>
</ol>
<p>  小结：迪米特法则的初衷是降低类之间的耦合，实现类型之间的高内聚，低耦合，这样可以解耦。但是凡事都有度，过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
