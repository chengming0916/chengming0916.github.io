<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"chengming0916.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Chemmy&#39;s Blog">
<meta property="og:url" content="http://chengming0916.github.io/page/16/index.html">
<meta property="og:site_name" content="Chemmy&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chemmy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://chengming0916.github.io/page/16/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Chemmy's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chemmy's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">chengming0916@outlook.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chemmy"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chemmy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengming0916" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengming0916" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/chengming0916@outlook.com" title="E-Mail → chengming0916@outlook.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2019/05/11/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Javascript/Nodejs%E6%B8%85%E7%90%86%E6%97%A0%E7%94%A8%E4%BE%9D%E8%B5%96%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/11/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Javascript/Nodejs%E6%B8%85%E7%90%86%E6%97%A0%E7%94%A8%E4%BE%9D%E8%B5%96%E5%8C%85/" class="post-title-link" itemprop="url">Nodejs清理无用依赖包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-11T00:00:00+08:00">2019-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>npm-check</p>
<p> npm-check 是一个检查依赖包是否存在过期、不正确、未使用等情况的工具。</p>
<p> 全局安装：</p>
<blockquote>
<p>npm  install  -g  npm-check</p>
</blockquote>
<p> 使用：</p>
<blockquote>
<p>npm-check</p>
</blockquote>
<p>上述指令会自动检查当前目录下的依赖包情况。</p>
<p> 这里我们重点关注下未使用的依赖包。npm-check 在检查依赖包是否使用时判断的依据是文件中是否存在 require（package） 这条语句，例如：</p>
<blockquote>
<p>const lodash &#x3D; require(‘lodash’);</p>
</blockquote>
<p>只要存在这条语句，即使我并未在其它任何地方使用（也就是说这是个无用的包），但是 npm-check 是不会将其判定为未使用的。</p>
<p> ESLint</p>
<p>为了解决上述存在的这种情况，我们可以借助 ESLint 先去检查代码是否存在未使用的变量（no-unused-vars），这样就可以检查某个包 require 了但并未在后续使用的情况。</p>
<p>全局安装：</p>
<blockquote>
<p>npm install -g eslint</p>
</blockquote>
<p>编写 .eslintrc.js 配置文件：</p>
<p> <img src="https://images2018.cnblogs.com/blog/1211559/201808/1211559-20180821151852625-130510713.jpg"></p>
<blockquote>
<p>eslint  –config  .eslintrc.js  .&#x2F;</p>
</blockquote>
<p>执行上述指令便会检查当前目录下的所有代码是否存在定义了但未使用的变量。删除掉未使用的变量（包含对依赖包的引用）之后，再运行 npm-check 便能正确的找出那些在项目中已不再使用的依赖包了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2019/04/12/Git/Git%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/12/Git/Git%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Git配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-12 14:19:37" itemprop="dateCreated datePublished" datetime="2019-04-12T14:19:37+08:00">2019-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:10" itemprop="dateModified" datetime="2025-12-04T16:58:10+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#配置用户名和邮箱</span></span><br><span class="line">git config --global user.name </span><br><span class="line">git config --global user.email</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置编码"><a href="#配置编码" class="headerlink" title="配置编码"></a>配置编码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#中文路径和文件名乱码</span></span><br><span class="line">git config --global core.quotePath <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改commit编码方式</span></span><br><span class="line">git config --global i18n.commitEncoding utf-8</span><br><span class="line">git config --global i18n.logOutputEncoding</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置内网域名证书"><a href="#配置内网域名证书" class="headerlink" title="配置内网域名证书"></a>配置内网域名证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.<span class="string">&quot;内网域名&quot;</span>.sslCAInfo <span class="string">&quot;证书所在路径&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">git config --global http.<span class="string">&quot;https://example.io&quot;</span>.sslCAInfo ~/.certs/selfsigned-root-ca.crt</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/10/06/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/WPF%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/06/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/WPF%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E4%BD%93/" class="post-title-link" itemprop="url">WPF自定义窗体</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-06 16:25:08" itemprop="dateCreated datePublished" datetime="2018-10-06T16:25:08+08:00">2018-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/" itemprop="url" rel="index"><span itemprop="name">DotNet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dino623/p/CustomWindowStyle.html">WPF]使用WindowChrome自定义Window Style - dino.c - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/choumengqizhigou/p/15739993.html">WPF自定义界面WindowChrome - 丑萌气质狗 - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dino623/p/custom_window_style_using_WindowChrome.html">WPF 自定义控件]﻿使用WindowChrome自定义Window Style - dino.c - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dino623/p/problems_of_WindowChrome.html">WPF 自定义控件]使用WindowChrome的问题 - dino.c - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/06/10/%E6%9D%82%E9%A1%B9/%E5%9C%A8CMD%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%88%87%E6%8D%A2%E5%88%B0%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/10/%E6%9D%82%E9%A1%B9/%E5%9C%A8CMD%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%88%87%E6%8D%A2%E5%88%B0%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">在CMD命令行中切换到管理员权限模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-10T00:00:00+08:00">2018-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>方式1：</p>
<p>搜索CMD Ctrl+Shift+Enter</p>
<p>方式2：</p>
<p>打开CMD，输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas /noprofile /user:Administrator cmd</span><br></pre></td></tr></table></figure>

<p>输入Administrator账户的密码</p>
<blockquote>
<p>runas 允许用户用其他权限运行指定的工具和程序</p>
<p>&#x2F;noprofile 指定不加载用户的配置文件</p>
<p>&#x2F;user:UserAccountName 指定在其下运行程序的账户</p>
</blockquote>
<p>常见问题</p>
<p>运行runas 指令输入密码报错“无法启动服务，原因可能是已被禁用或与其关联的设备没有启动。”</p>
<p>这是因为“Secondary Logo”服务没有启动，这个服务是”在不同凭据下启用启动过程“。直接在cmd中输入services.msc,将服务从禁用改为手动就好了，之后再次输入runas命令就可以使用administrator账户运行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/05/24/Linux/Linux%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%8F%8ASSH%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/24/Linux/Linux%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%8F%8ASSH%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Linux配置网络及SSH配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-24 16:57:52" itemprop="dateCreated datePublished" datetime="2018-05-24T16:57:52+08:00">2018-05-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:10" itemprop="dateModified" datetime="2025-12-04T16:58:10+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="识别接口名称"><a href="#识别接口名称" class="headerlink" title="识别接口名称"></a>识别接口名称</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要 net-tools</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用标准的<strong>ifconfig</strong>命令没有显示出接口，尝试使用带有<code>-a</code>选项的相同的命令。这个选项强制这个工具去显示系统检测到的所有的网络接口，不管他们是up或down状态。如果<strong>ifconfig -a</strong>没有提供结果，则硬件有错误或者接口驱动没有加载到内核中。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 新版本系统大部分支持</span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure>



<h4 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h4><p>DHCP（动态主机配置协议）使自动接受网络信息（IP地址、掩码、广播地址、网关、名称服务器等）变得容易。这只在网络中有DHCP服务器（或者如果ISP提供商提供一个DHCP服务）时有用.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dhcpcd eth0 # eth0 为网口名称,根据上一步识别出的接口名称修改</span><br></pre></td></tr></table></figure>



<h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用/禁用网卡</span></span><br><span class="line">ifconfig eth0 up/down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置IP地址及掩码</span></span><br><span class="line">ifconfig eth0 &#123;IP地址&#125; netmask &#123;掩码&#125; up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认网关</span></span><br><span class="line">route add default gw &#123;网关&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置DNS</span></span><br><span class="line">nano -w /etc.resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用下边模板填充</span></span><br><span class="line">nameserver &#123;名称服务器&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>花括号中内容使用具体的地址填充</p>
</blockquote>
<h4 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用/禁用网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 up/down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Ip地址及掩码,掩码一般用 24 相当于255.255.255.0</span></span><br><span class="line">ip addr add &#123;IP地址&#125;/&#123;掩码&#125; dev eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">ip addr del dev eth0 &#123;IP&#125;/&#123;掩码&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新接口IP(删除所有)</span></span><br><span class="line">ip addr flush eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认网关</span></span><br><span class="line">ip route add default via &#123;网关&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>网关的配置参考</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sudochen/p/15992994.html">ip route命令</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/meihualing/article/details/113058719">Linux上添加路由，删除路由，修改路由配置（route add, route del, 路由表项基本知识）</a></p>
<blockquote>
<p>| 子网掩码用来划分网络区域<br>| 子网掩码非0的位对应的ip上的数字表示这个ip的网络位<br>| 子网掩码0位对应的数字是ip的主机位<br>| 网络位表示网络区域<br>| 主机位表示网络区域里某台主机<br>|<br>| 11111111.11111111.11111111.00000000 &#x3D; 255.255.255.0 &#x3D; 24<br>| ——————————————  —————<br>|          网络位                                      主机位</p>
<p>| 网络位一致，主机位不一致的2个IP可以直接通讯<br>|<br>| 172.25.254.10&#x2F;24         #24&#x3D;255.255.255.0<br>|<br>| 172.25.254.20&#x2F;24<br>|<br>| 172.25.0.1&#x2F;16            #16&#x3D;255.255.0.0<br>| 前两个可以直接通讯，最后一个与其他俩个不能直接通讯</p>
</blockquote>
<h4 id="无线网连接"><a href="#无线网连接" class="headerlink" title="无线网连接"></a>无线网连接</h4><p>当使用一块无线（802.11）网卡，在继续之前需要先配置无线设置。要查看当前无线网卡的设置，你可以使用<strong>iw</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看连接信息</span></span><br><span class="line">iw dev wlan0 info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查连接状态</span></span><br><span class="line">iw dev wlan0 <span class="built_in">link</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接网络 （确保接口处于活动状态）</span></span><br><span class="line">iw dev wlan0 connect -w &#123;网络名称&#125; key 0:d:&#123;密码&#125; </span><br></pre></td></tr></table></figure>

<p>如果无线网络配置为WPA或WPA2，则需要使用<strong>wpa_supplicant</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找附近热点</span></span><br><span class="line">wpa_cli -i wlan0 scan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连接配置文件</span></span><br><span class="line">wpa_passphrase &#123;网络名称&#125; &#123;密码&#125; &gt; /etc/wpa_supplicant.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接网络</span></span><br><span class="line"><span class="comment"># -D 驱动程序名称（可以是多个驱动程序：nl80211,wext）</span></span><br><span class="line"><span class="comment"># -i 接口名称</span></span><br><span class="line"><span class="comment"># -c 配置文件</span></span><br><span class="line"><span class="comment"># -B 在后台运行守护进程</span></span><br><span class="line">wpa_supplicant -D nl80211 -i wlan0 -c /etc/wpa_supplicant.conf -B</span><br></pre></td></tr></table></figure>



<h4 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nano -w /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放开注释</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用SSH密钥对登录，取消如下行的注释符</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">AuthorizeKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h4 id="启动SSHD"><a href="#启动SSHD" class="headerlink" title="启动SSHD"></a>启动SSHD</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动SSH服务(需要有可登录的账户)</span></span><br><span class="line">/etc/init.d/sshd start</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/05/12/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8(RPC)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/12/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8(RPC)/" class="post-title-link" itemprop="url">[译]RabbitMQ教程C#版 - 远程过程调用(RPC)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-12T00:00:00+08:00">2018-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/" itemprop="url" rel="index"><span itemprop="name">DotNet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>先决条件</strong><br>本教程假定 RabbitMQ 已经安装，并运行在<code>localhost</code> 标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。</p>
<p><strong>从哪里获得帮助</strong><br>如果您在阅读本教程时遇到困难，可以通过邮件列表 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/rabbitmq-users">联系我们</a>。</p>
</blockquote>
<p>在第 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html">教程[2]</a> 中，我们学习了如何使用工作队列在多个工作单元之间分配耗时任务。</p>
<p>但是如果我们想要运行一个在远程计算机上的函数并等待其结果呢？这将是另外一回事了。这种模式通常被称为 <em>远程过程调用</em> 或 <em>RPC</em> 。</p>
<p>在本篇教程中，我们将使用 RabbitMQ 构建一个 RPC 系统：一个客户端和一个可扩展的 RPC 服务器。由于我们没有什么耗时任务值得分发，那干脆就创建一个返回斐波那契数列的虚拟 RPC 服务吧。</p>
<h2 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口#"></a>客户端接口<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3">#</a></h2><p>为了说明如何使用 RPC 服务，我们将创建一个简单的客户端类。该类将暴露一个名为<code>Call</code>的方法，用来发送 RPC 请求并且保持阻塞状态，直到接收到应答为止。</p>
<pre><code>var rpcClient = new RPCClient();

Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);
var response = rpcClient.Call(&quot;30&quot;);
Console.WriteLine(&quot; [.] Got &#39;&#123;0&#125;&#39;&quot;, response);

rpcClient.Close();
</code></pre>
<blockquote>
<p><strong>关于 RPC 的说明</strong></p>
<p>尽管 RPC 在计算机中是一种很常见的模式，但它经常受到批评。问题出现在当程序员不知道一个函数是本地调用还是一个耗时的 RPC 请求。这样的混淆，会导致系统不可预测，以及给调试增加不必要的复杂性。误用 RPC 可能会导致不可维护的混乱代码，而不是简化软件。</p>
<p>牢记这些限制，请考虑如下建议：</p>
<ul>
<li>确保可以明显区分哪些函数是本地调用，哪些是远程调用。</li>
<li>为您的系统编写文档，明确组件之间的依赖关系。</li>
<li>捕获异常，当 RPC 服务长时间宕机时客户端该如何应对。</li>
</ul>
<p>当有疑问的时候可以先避免使用 RPC。如果可以的话，考虑使用异步管道 - 而不是类似 RPC 的阻塞，其会将结果以异步的方式推送到下一个计算阶段。</p>
</blockquote>
<h2 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列#"></a>回调队列<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html#%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97">#</a></h2><p>一般来讲，基于 RabbitMQ 进行 RPC 通信是非常简单的，客户端发送一个请求消息，然后服务端用一个响应消息作为应答。为了能接收到响应，我们需要在发送请求过程中指定一个’callback’队列地址。</p>
<pre><code>var props = channel.CreateBasicProperties();
props.ReplyTo = replyQueueName;

var messageBytes = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: &quot;&quot;,
                     routingKey: &quot;rpc_queue&quot;,
                     basicProperties: props,
                     body: messageBytes);
</code></pre>
<p>​<br>​    </p>
<blockquote>
<p><strong>消息属性</strong></p>
<p>AMQP 0-9-1 协议在消息中预定义了一个包含 14 个属性的集合，大多数属性很少使用，但以下情况除外：<br><code>Persistent</code>：将消息标记为持久的（值为2）或者瞬时的（其他值），可以参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html">教程[2]</a>。<br><code>DeliveryMode</code>：熟悉 AMQP 协议的人可以选择此属性而不是熟悉协议的人可以选择使用此属性而不是<code>Persistent</code>，它们控制的东西是一样的。<br><code>ContentType</code>：用于描述编码的 mime 类型。例如，对于经常使用的 JSON 编码，将此属性设置为：<code>application/json</code>是一种很好的做法。<br><code>ReplyTo</code>：通常用于命名回调队列。<br><code>CorrelationId</code>：用于将 RPC 响应与请求相关联。</p>
</blockquote>
<h2 id="关联ID"><a href="#关联ID" class="headerlink" title="关联ID#"></a>关联ID<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html#%E5%85%B3%E8%81%94id">#</a></h2><p>在上面介绍的方法中，我们建议为每个 RPC 请求创建一个回调队列，但是这种方式效率低。幸运的是我们有一种更好的方式，那就是为每个客户端创建一个独立的回调队列。</p>
<p>这种方式会引出一个新的问题，在收到响应的回调队列中，它无法区分响应属于哪一个请求，此时便是<code>CorrelationId</code>属性的所用之处。我们将为每个请求的<code>CorrelationId</code>设置一个唯一值。之后当我们在回调队列接收到响应的时候，再去检查下这个属性是否和请求中的值匹配，如此一来，我们就可以把响应和请求关联起来了。如果出现一个未知的<code>CorrelationId</code>值，我们可以安全的销毁这个消息，因为这个消息不属于我们的请求。</p>
<p>你可能会问，为什么我们应该忽略回调队列中的未知的消息，而不是用错误来标识失败呢？这是因为于服务器端可能存在竞争条件。虽然不太可能，但是 RPC 服务器可能在仅发送了响应消息而未发送消息确认的情况下挂掉，如果出现这种情况，RPC 服务器重启之后将会重新处理该请求。这就是为什么在客户端上我们必须优雅地处理重复的响应，并且理想情况下 RPC 应该是幂等的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结#"></a>总结<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html#%E6%80%BB%E7%BB%93">#</a></h2><p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117212349010-1581646652.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117212349010-1581646652.png"></a></p>
<p>我们的 RPC 会是这样工作：</p>
<ul>
<li>客户端启动时，会创建一个匿名的独占回调队列。</li>
<li>对于 RPC 请求，客户端发送带有两个属性的消息：<code>ReplyTo</code>（设置为回调队列）和<code>CorrelationId</code>（为每个请求设置唯一值）。</li>
<li>请求被发送到<code>rpc_queue</code>队列。</li>
<li>RPC 工作线程（或者叫：服务器）正在等待该队列上的请求。当出现请求时，它会执行该作业，并使用<code>ReplyTo</code>属性设置的队列将带有结果的消息发送回客户端。</li>
<li>客户端等待回调队列上的数据。出现消息时，它会检查<code>CorrelationId</code>属性。如果它与请求中的值匹配，则返回对应用程序的响应。</li>
</ul>
<h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起#"></a>组合在一起<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html#%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7">#</a></h2><p>斐波纳契 任务：</p>
<pre><code>private static int fib(int n)
&#123;
    if (n == 0 || n == 1) return n;
    return fib(n - 1) + fib(n - 2);
&#125;
</code></pre>
<p>我们宣布我们的斐波那契函数。并假定只允许有效的正整数输入。 （不要期望这个适用于大数字，它可能是最慢的递归实现）。</p>
<p>我们的 RPC 服务端代码 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCServer/RPCServer.cs">RPCServer.cs</a> 看起来如下所示：</p>
<pre><code>using System;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;

class RPCServer
&#123;
    public static void Main()
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using (var connection = factory.CreateConnection())
        using (var channel = connection.CreateModel())
        &#123;
            channel.QueueDeclare(queue: &quot;rpc_queue&quot;, durable: false,
              exclusive: false, autoDelete: false, arguments: null);
            channel.BasicQos(0, 1, false);
            var consumer = new EventingBasicConsumer(channel);
            channel.BasicConsume(queue: &quot;rpc_queue&quot;,
              autoAck: false, consumer: consumer);
            Console.WriteLine(&quot; [x] Awaiting RPC requests&quot;);

            consumer.Received += (model, ea) =&gt;
            &#123;
                string response = null;

                var body = ea.Body;
                var props = ea.BasicProperties;
                var replyProps = channel.CreateBasicProperties();
                replyProps.CorrelationId = props.CorrelationId;

                try
                &#123;
                    var message = Encoding.UTF8.GetString(body);
                    int n = int.Parse(message);
                    Console.WriteLine(&quot; [.] fib(&#123;0&#125;)&quot;, message);
                    response = fib(n).ToString();
                &#125;
                catch (Exception e)
                &#123;
                    Console.WriteLine(&quot; [.] &quot; + e.Message);
                    response = &quot;&quot;;
                &#125;
                finally
                &#123;
                    var responseBytes = Encoding.UTF8.GetBytes(response);
                    channel.BasicPublish(exchange: &quot;&quot;, routingKey: props.ReplyTo,
                      basicProperties: replyProps, body: responseBytes);
                    channel.BasicAck(deliveryTag: ea.DeliveryTag,
                      multiple: false);
                &#125;
            &#125;;

            Console.WriteLine(&quot; Press [enter] to exit.&quot;);
            Console.ReadLine();
        &#125;
    &#125;
</code></pre>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​        private static int fib(int n)<br>​        {<br>​            if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1)<br>​            {<br>​                return n;<br>​            }<br>​<br>​            return fib(n - 1) + fib(n - 2);<br>​        }<br>​    }</p>
<p>服务端代码非常简单：</p>
<ul>
<li>像往常一样，首先建立连接，通道和声明队列。</li>
<li>我们可能希望运行多个服务器进程。为了在多个服务器上平均分配负载，我们需要设置<code>channel.BasicQos</code>中的<code>prefetchCount</code>值。</li>
<li>使用<code>BasicConsume</code>访问队列，然后注册一个交付处理程序，并在其中完成工作并发回响应。</li>
</ul>
<p>我们的 RPC 客户端 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCClient/RPCClient.cs">RPCClient.cs</a> 代码：</p>
<pre><code>using System;
using System.Collections.Concurrent;
using System.Text;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;

public class RpcClient
&#123;
    private readonly IConnection connection;
    private readonly IModel channel;
    private readonly string replyQueueName;
    private readonly EventingBasicConsumer consumer;
    private readonly BlockingCollection&lt;string&gt; respQueue = new BlockingCollection&lt;string&gt;();
    private readonly IBasicProperties props;

public RpcClient()
&#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;

        connection = factory.CreateConnection();
        channel = connection.CreateModel();
        replyQueueName = channel.QueueDeclare().QueueName;
        consumer = new EventingBasicConsumer(channel);

        props = channel.CreateBasicProperties();
        var correlationId = Guid.NewGuid().ToString();
        props.CorrelationId = correlationId;
        props.ReplyTo = replyQueueName;

        consumer.Received += (model, ea) =&gt;
        &#123;
            var body = ea.Body;
            var response = Encoding.UTF8.GetString(body);
            if (ea.BasicProperties.CorrelationId == correlationId)
            &#123;
                respQueue.Add(response);
            &#125;
        &#125;;
    &#125;

    public string Call(string message)
    &#123;
        var messageBytes = Encoding.UTF8.GetBytes(message);
        channel.BasicPublish(
            exchange: &quot;&quot;,
            routingKey: &quot;rpc_queue&quot;,
            basicProperties: props,
            body: messageBytes);

        channel.BasicConsume(
            consumer: consumer,
            queue: replyQueueName,
            autoAck: true);

        return respQueue.Take(); ;
    &#125;

    public void Close()
    &#123;
        connection.Close();
    &#125;
&#125;

public class Rpc
&#123;
    public static void Main()
    &#123;
        var rpcClient = new RpcClient();

        Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);
        var response = rpcClient.Call(&quot;30&quot;);

        Console.WriteLine(&quot; [.] Got &#39;&#123;0&#125;&#39;&quot;, response);
        rpcClient.Close();
    &#125;
&#125;
</code></pre>
<p>客户端代码稍微复杂一些：</p>
<ul>
<li>建立连接和通道，并为响应声明一个独有的 ‘callback’ 队列。</li>
<li>订阅这个 ‘callback’ 队列，以便可以接收到 RPC 响应。</li>
<li><code>Call</code>方法用来生成实际的 RPC 请求。</li>
<li>在这里，我们首先生成一个唯一的<code>CorrelationId</code>编号并保存它，while 循环会使用该值来捕获匹配的响应。</li>
<li>接下来，我们发布请求消息，其中包含两个属性：<code>ReplyTo</code>和<code>CorrelationId</code>。</li>
<li>此时，我们可以坐下来稍微一等，直到指定的响应到来。</li>
<li>while 循环做的工作非常简单，对于每个响应消息，它都会检查<code>CorrelationId</code>是否是我们正在寻找的那一个。如果是这样，它就会保存该响应。</li>
<li>最后，我们将响应返回给用户。</li>
</ul>
<p>客户发出请求：</p>
<pre><code>var rpcClient = new RPCClient();

Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);
var response = rpcClient.Call(&quot;30&quot;);
Console.WriteLine(&quot; [.] Got &#39;&#123;0&#125;&#39;&quot;, response);

rpcClient.Close();
</code></pre>
<p>现在是查看 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCClient/RPCClient.cs">RPCClient.cs</a> 和 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCServer/RPCServer.cs">RPCServer.cs</a> 的完整示例源代码（包括基本异常处理）的好时机哦。</p>
<p>像往常一样设置（请参见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html">教程[1]</a>）：</p>
<p>我们的 RPC 服务现已准备就绪，现在可以启动服务端：</p>
<pre><code>cd RPCServer
dotnet run
</code></pre>
<p>​    </p>
<p>要请求斐波纳契数，请运行客户端：</p>
<pre><code>cd RPCClient
dotnet run
</code></pre>
<p>​    </p>
<p>这里介绍的设计并不是 RPC 服务的唯一可能实现，但它仍具有一些重要优势：</p>
<ul>
<li>如果 RPC 服务器太慢，您可以通过运行另一个服务器来扩展。尝试在新开一个控制台，运行第二个 RPCServer。</li>
<li>在客户端，RPC 只需要发送和接收一条消息。不需要像<code>QueueDeclare</code>一样同步调用。因此，对于单个 RPC 请求，RPC 客户端只需要一次网络往返。</li>
</ul>
<p>我们的代码很简单，也并没有尝试去解决更复杂（但很重要）的问题，比如就像：</p>
<ul>
<li>如果服务端没有运行，客户端应该如何反应？</li>
<li>客户端是否应该为 RPC 设置某种超时机制？</li>
<li>如果服务端出现故障并引发异常，是否应将其转发给客户端？</li>
<li>在处理之前防止无效的传入消息（例如：检查边界、类型）。</li>
</ul>
<blockquote>
<p>如果您想进行实验，您可能会发现 <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/management.html">管理 UI</a> 对于查看队列非常有用。</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后#"></a>写在最后<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">#</a></h2><p>本文翻译自 RabbitMQ 官方教程 C# 版本。如本文介绍内容与官方有所出入，请以官方最新内容为准。水平有限，翻译的不好请见谅，如有翻译错误还请指正。</p>
<ul>
<li>原文链接：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-six-dotnet.html">RabbitMQ tutorial - Remote procedure call (RPC)</a></li>
<li>实验环境：RabbitMQ 3.7.4 、.NET Core 2.1.3、Visual Studio Code</li>
<li>最后更新：2018-11-17</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/05/05/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/05/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">[译]RabbitMQ教程C#版 - 路由</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-05T00:00:00+08:00">2018-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/" itemprop="url" rel="index"><span itemprop="name">DotNet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>先决条件</strong><br>本教程假定 RabbitMQ 已经安装，并运行在<code>localhost</code> 标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。</p>
<p><strong>从哪里获得帮助</strong><br>如果您在阅读本教程时遇到困难，可以通过邮件列表 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/rabbitmq-users">联系我们</a>。</p>
</blockquote>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由#"></a>路由<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E8%B7%AF%E7%94%B1">#</a></h2><p><strong>（使用.NET客户端）</strong></p>
<p>在 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html">教程[3]</a> 中，我们构建了一个简单的日志系统，可以向多个接收者广播消息。</p>
<p>在本教程中，我们会为日志系统再添加一个特性，使其可以只订阅消息的一个子集。例如，将所有日志消息打印到<br>控制台，同时只会将严重错误消息写入日志文件（保存到磁盘空间）。</p>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定#"></a>绑定<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E7%BB%91%E5%AE%9A">#</a></h2><p>在前面的例子中，我们创建过_绑定_。不知道您是否还记得下面的代码：</p>
<pre><code>channel.QueueBind(queue: queueName,
                  exchange: &quot;logs&quot;,
                  routingKey: &quot;&quot;);
</code></pre>
<p>绑定是指交换器和队列之间的关联关系。可以简单地理解为：某个队列对来自此交换器的消息感兴趣。</p>
<p>绑定可以采用额外的<code>routingKey</code>参数，为了避免与<code>BasicPublish</code>方法中相同参数混淆，我们将其称为<code>binding key</code>（这里是指路由键从声明角度的一种别称，绑定键）。下面即是如何使用绑定键 建立一个绑定：</p>
<pre><code>channel.QueueBind(queue: queueName,
                  exchange: &quot;direct_logs&quot;,
                  routingKey: &quot;black&quot;);
</code></pre>
<p>绑定键的含义取决于交换器类型。像我们前面使用的<code>fanout</code> 交换器，忽略了它的值（依据<code>fanout</code>交换器的特性，它会把消息广播到所有订阅的队列，所以就算指定<code>routingKey</code>也不会根据其过滤消息）。</p>
<h2 id="Direct交换器"><a href="#Direct交换器" class="headerlink" title="Direct交换器#"></a>Direct交换器<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#direct%E4%BA%A4%E6%8D%A2%E5%99%A8">#</a></h2><p>在上篇教程中，我们的日志系统会把所有消息广播给所有消费者，现在我们想要扩展使其可以根据消息的严重性过滤消息。例如，我们希望将日志消息写入磁盘的脚本仅接收严重错误的消息，而不是在警告或者信息类型的消息上浪费磁盘空间。</p>
<p>之前我们使用的是<code>fanout</code>交换器，它没有给我们足够的灵活性 - 它只能进行无意识的广播。</p>
<p>现在我们要用<code>direct</code>交换器替换它，<code>direct</code>交换器背后的路由算法很简单 - 消息会进入其<code>binding key</code>恰好与<code>routing key</code>相匹配的队列。<br>为了说明这一点，请参考以下设置：</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231746073-139207930.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231746073-139207930.png"></a></p>
<p>在上面的设置中，我们可以看到<code>direct</code>交换器<code>X</code>与两个队列绑定。第一个队列通过键<code>orange</code>绑定，第二个队列有两个绑定，一个通过键<code>black</code>绑定、另外一个通过键<code>green</code>绑定。</p>
<p>如此设置，发布使用路由键<code>orange</code>的消息到交换器最终会被路由到队列<code>Q1</code>，路由键为<code>black</code>或<code>green</code>的消息会去向队列<code>Q2</code>，而其他所有的消息会被丢弃。</p>
<h2 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定#"></a>多重绑定<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A">#</a></h2><p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231813076-1280701060.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231813076-1280701060.png"></a></p>
<p>使用相同的绑定键绑定多个队列是完全合法的。在示例中，我们可以在<code>X</code>和<code>Q1</code>之间添加一个键为<code>black</code>的绑定。这种情况下，<code>direct</code>交换器会像<code>fanout</code>交换器一样，把消息广播到所有匹配的队列，路由键为<code>black</code>的消息会被分别发送到队列<code>Q1</code>和<code>Q2</code>。</p>
<h2 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志#"></a>发送日志<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E5%8F%91%E9%80%81%E6%97%A5%E5%BF%97">#</a></h2><p>我们将在日志系统中使用上述消息模型，在发送消息时使用<code>direct</code>交换机来替换<code>fanout</code>交换器。同时我们会把日志的严重性作为路由键，这样的话，接收脚本就可以选择性地接收它期望严重性的消息。首先我们来关注如何发送日志。</p>
<p>同样地，我们需要先创建一个交换器：</p>
<pre><code>channel.ExchangeDeclare(exchange: &quot;direct_logs&quot;, type: ExchangeType.Direct);
</code></pre>
<p>准备好发送消息：</p>
<pre><code>var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: &quot;direct_logs&quot;,
                     routingKey: severity,
                     basicProperties: null,
                     body: body);
</code></pre>
<p>简单起见，我们先假定<code>severity</code>可以是<code>info</code>、<code>warning</code>或<code>error</code>任意一值。</p>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅#"></a>订阅<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E8%AE%A2%E9%98%85">#</a></h2><p>马上就可以像前面的教程接收消息了，但有一点不同， 我们需要为我们感兴趣的每种日志严重性级别的消息建立一个新的绑定。</p>
<pre><code>var queueName = channel.QueueDeclare().QueueName;

foreach(var severity in args)
&#123;
    channel.QueueBind(queue: queueName,
                      exchange: &quot;direct_logs&quot;,
                      routingKey: severity);
&#125;
</code></pre>
<h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起#"></a>组合在一起<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7">#</a></h2><p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231857862-1124037273.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231857862-1124037273.png"></a></p>
<p><code>EmitLogDirect.cs</code>类的代码：</p>
<pre><code>using System;
using System.Linq;
using RabbitMQ.Client;
using System.Text;

class EmitLogDirect
&#123;
    public static void Main(string[] args)
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        &#123;
            channel.ExchangeDeclare(exchange: &quot;direct_logs&quot;,
                                    type: &quot;direct&quot;);

            var severity = (args.Length &gt; 0) ? args[0] : &quot;info&quot;;
            var message = (args.Length &gt; 1)
                          ? string.Join(&quot; &quot;, args.Skip(1).ToArray())
                          : &quot;Hello World!&quot;;
            var body = Encoding.UTF8.GetBytes(message);
            channel.BasicPublish(exchange: &quot;direct_logs&quot;,
                                 routingKey: severity,
                                 basicProperties: null,
                                 body: body);
            Console.WriteLine(&quot; [x] Sent &#39;&#123;0&#125;&#39;:&#39;&#123;1&#125;&#39;&quot;, severity, message);
        &#125;

        Console.WriteLine(&quot; Press [enter] to exit.&quot;);
        Console.ReadLine();
    &#125;
&#125;
</code></pre>
<p><code>ReceiveLogsDirect.cs</code>类的代码：</p>
<pre><code>using System;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;

class ReceiveLogsDirect
&#123;
    public static void Main(string[] args)
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        &#123;
            channel.ExchangeDeclare(exchange: &quot;direct_logs&quot;,
                                    type: &quot;direct&quot;);
            var queueName = channel.QueueDeclare().QueueName;

            if(args.Length &lt; 1)
            &#123;
                Console.Error.WriteLine(&quot;Usage: &#123;0&#125; [info] [warning] [error]&quot;,
                                        Environment.GetCommandLineArgs()[0]);
                Console.WriteLine(&quot; Press [enter] to exit.&quot;);
                Console.ReadLine();
                Environment.ExitCode = 1;
                return;
            &#125;

            foreach(var severity in args)
            &#123;
                channel.QueueBind(queue: queueName,
                                  exchange: &quot;direct_logs&quot;,
                                  routingKey: severity);
            &#125;

            Console.WriteLine(&quot; [*] Waiting for messages.&quot;);

            var consumer = new EventingBasicConsumer(channel);
            consumer.Received += (model, ea) =&gt;
            &#123;
                var body = ea.Body;
                var message = Encoding.UTF8.GetString(body);
                var routingKey = ea.RoutingKey;
                Console.WriteLine(&quot; [x] Received &#39;&#123;0&#125;&#39;:&#39;&#123;1&#125;&#39;&quot;,
                                  routingKey, message);
            &#125;;
            channel.BasicConsume(queue: queueName,
                                 autoAck: true,
                                 consumer: consumer);

            Console.WriteLine(&quot; Press [enter] to exit.&quot;);
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<p>请像往常一样创建项目（请参阅 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html">教程[1]</a>）。</p>
<p>如果您想将<code>warning</code>和<code>error</code>（不包括<code>info</code>）日志消息保存到文件，只需打开控制台并输入：</p>
<pre><code>cd ReceiveLogsDirect
dotnet run warning error &gt; logs_from_rabbit.log
</code></pre>
<p>如果您想在屏幕上看到所有日志消息，请打开一个新终端并执行以下操作：</p>
<pre><code>cd ReceiveLogsDirect
dotnet run info warning error
</code></pre>
<p>​    </p>
<p>例如，想要发出<code>error</code>日志消息，只需要输入：</p>
<pre><code>cd EmitLogDirect
dotnet run error &quot;Run. Run. Or it will explode.&quot;
</code></pre>
<p>​    </p>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/EmitLogDirect/EmitLogDirect.cs">EmitLogDirect.cs</a> 和 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/ReceiveLogsDirect/ReceiveLogsDirect.cs">ReceiveLogsDirect.cs</a> 的完整源代码。</p>
<p>跳转到 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-topics.html">教程[5]</a>，了解如何基于模式监听消息。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后#"></a>写在最后<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">#</a></h2><p>本文翻译自 RabbitMQ 官方教程 C# 版本。如本文介绍内容与官方有所出入，请以官方最新内容为准。水平有限，翻译的不好请见谅，如有翻译错误还请指正。</p>
<ul>
<li>原文链接：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-four-dotnet.html">RabbitMQ tutorial - Routing</a></li>
<li>实验环境：RabbitMQ 3.7.4 、.NET Core 2.1.3、Visual Studio Code</li>
<li>最后更新：2018-08-31</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/04/28/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/28/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">[译]RabbitMQ教程C#版 - 工作队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-28 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-28T00:00:00+08:00">2018-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/" itemprop="url" rel="index"><span itemprop="name">DotNet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>先决条件</strong><br>本教程假定 RabbitMQ 已经安装，并运行在<code>localhost</code> 标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。</p>
<p><strong>从哪里获得帮助</strong><br>如果您在阅读本教程时遇到困难，可以通过邮件列表 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/rabbitmq-users">联系我们</a>。</p>
</blockquote>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列#"></a>工作队列<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97">#</a></h2><p><strong>（使用 .NET Client）</strong></p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231201957-1092292813.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231201957-1092292813.png"></a></p>
<p>在 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html">教程[1]</a> 中，我们编写了两个程序，用于从一个指定的队列发送和接收消息。在本文中，我们将创建一个_工作队列_，用于在多个工作线程间分发耗时的任务。</p>
<p>工作队列（又名：任务队列）背后的主要想法是避免立即执行资源密集型、且必须等待其完成的任务。相反的，我们把这些任务安排在稍后完成。我们可以将任务封装为消息并把它发送到队列中，在后台运行的工作进程将从队列中取出任务并最终执行。当您运行多个工作线程，这些任务将在这些工作线程之间共享。</p>
<p>这个概念在Web应用程序中特别有用，因为在一个 HTTP 请求窗口中无法处理复杂的任务。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备#"></a>准备<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E5%87%86%E5%A4%87">#</a></h2><p>我们将略微修改上一个示例中的_Send_程序，以其可以在命令行发送任意消息。<br>这个程序将调度任务到我们的工作队列中，所以让我们把它命名为<code>NewTask</code>：</p>
<p>像 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html">教程[1]</a>一样，我们需要生成两个项目：</p>
<pre><code>dotnet new console --name NewTask
mv NewTask/Program.cs NewTask/NewTask.cs

dotnet new console --name Worker
mv Worker/Program.cs Worker/Worker.cs

cd NewTask
dotnet add package RabbitMQ.Client
dotnet restore

cd ../Worker
dotnet add package RabbitMQ.Client
dotnet restore


var message = GetMessage(args);
var body = Encoding.UTF8.GetBytes(message);

var properties = channel.CreateBasicProperties();
properties.Persistent = true;

channel.BasicPublish(exchange: &quot;&quot;,
                     routingKey: &quot;task_queue&quot;,
                     basicProperties: properties,
                     body: body);
</code></pre>
<p>从命令行参数获取消息的帮助方法：</p>
<pre><code>private static string GetMessage(string[] args)
&#123;
    return ((args.Length &gt; 0) ? string.Join(&quot; &quot;, args) : &quot;Hello World!&quot;);
&#125;
</code></pre>
<p>我们旧的<code>Receive.cs</code>脚本也需要进行一些更改：它需要为消息体中的每个点模拟一秒种的时间消耗。它将处理由 RabbitMQ 发布的消息，并执行任务，因此我们把它复制到<code>Worker</code>项目并修改：</p>
<pre><code>var consumer = new EventingBasicConsumer(channel);
</code></pre>
<p>​<br>​    consumer.Received +&#x3D; (model, ea) &#x3D;&gt;<br>​    {<br>​        var body &#x3D; ea.Body;<br>​        var message &#x3D; Encoding.UTF8.GetString(body);<br>​        Console.WriteLine(“ [x] Received {0}”, message);</p>
<p>​<br>​        int dots &#x3D; message.Split(‘.’).Length - 1;<br>​        Thread.Sleep(dots * 1000);<br>​<br>​        Console.WriteLine(“ [x] Done”);<br>​    };<br>​<br>    channel.BasicConsume(queue: “task_queue”, autoAck: true, consumer: consumer);</p>
<p>模拟虚拟任务的执行时间：</p>
<pre><code>int dots = message.Split(&#39;.&#39;).Length - 1;
Thread.Sleep(dots * 1000);
</code></pre>
<h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度#"></a>循环调度<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E5%BE%AA%E7%8E%AF%E8%B0%83%E5%BA%A6">#</a></h2><p>使用任务队列的优点之一是能够轻松地并行工作。如果我们正在积累积压的工作，我们仅要增加更多的工作者，并以此方式可以轻松扩展。</p>
<p>首先，我们尝试同时运行两个<code>Worker</code>实例。他们都会从队列中获取消息，但究竟如何？让我们来看看。</p>
<p>您需要打开三个控制台，两个运行<code>Worker</code>程序，这些控制台作为我们的两个消费者 - C1和C2。</p>
<pre><code>cd Worker
dotnet run
</code></pre>
<p>​    </p>
<pre><code>cd Worker
dotnet run
</code></pre>
<p>​    </p>
<p>在第三个控制台中，我们将发布一些新的任务。一旦你已经运行了消费者，你可以尝试发布几条消息：</p>
<pre><code>cd NewTask
dotnet run &quot;First message.&quot;
dotnet run &quot;Second message..&quot;
dotnet run &quot;Third message...&quot;
dotnet run &quot;Fourth message....&quot;
dotnet run &quot;Fifth message.....&quot;
</code></pre>
<p>让我们看看有什么发送到了我们的<code>Worker</code>程序：</p>
<pre><code># shell 1
# =&gt; [*] Waiting for messages. To exit press CTRL+C
# =&gt; [x] Received &#39;First message.&#39;
# =&gt; [x] Received &#39;Third message...&#39;
# =&gt; [x] Received &#39;Fifth message.....&#39;


# shell 2
# =&gt; [*] Waiting for messages. To exit press CTRL+C
# =&gt; [x] Received &#39;Second message..&#39;
# =&gt; [x] Received &#39;Fourth message....&#39;
</code></pre>
<p>默认情况下，RabbitMQ 会按顺序将每条消息发送给下一个消费者。消费者数量平均的情况下，每个消费者将会获得相同数量的消息。这种分配消息的方式称为循环（Round-Robin）。请尝试开启三个或更多的<code>Worker</code>程序来验证。</p>
<h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认#"></a>消息确认<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4">#</a></h2><p>处理一项任务可能会需要几秒钟的时间。如果其中一个消费者开启了一项长期的任务并且只完成了部分就挂掉了，您可能想知道会发生什么？在我们当前的代码中，一旦 RabbitMQ 把消息分发给了消费者，它会立即将这条消息标记为删除。在这种情况下，如果您停掉某一个 Worker，我们将会丢失这条正在处理的消息，也将丢失所有分发到该 Worker 但尚未处理的消息。</p>
<p>但是我们不想丢失任何一个任务。如果一个 Worker 挂掉了，我们希望这个任务能被重新分发给其他 Worker。</p>
<p>为了确保消息永远不会丢失，RabbitMQ 支持 <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/confirms.html"><em>消息确认</em></a> 机制。消费者回发一个确认信号 Ack(nowledgement) 给 RabbitMQ，告诉它某个消息已经被接收、处理并且可以自由删除它。</p>
<p>如果一个消费者在还没有回发确认信号之前就挂了（其通道关闭，连接关闭或者 TCP 连接丢失），RabbitMQ 会认为该消息未被完全处理，并将其重新排队。如果有其他消费者同时在线，该消息将会被会迅速重新分发给其他消费者。这样，即便 Worker 意外挂掉，也可以确保消息不会丢失。</p>
<p>没有任何消息会超时；当消费者死亡时，RabbitMQ 将会重新分发消息。即使处理消息需要非常非常长的时间也没关系。</p>
<p>默认情况下，<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/confirms.html">手动消息确认</a> 模式是开启的。在前面的例子中，我们通过将<code>autoAck</code>（“自动确认模式”）参数设置为<code>true</code>来明确地关闭手动消息确认模式。一旦完成任务，是时候删除这个标志并且从 Worker 手动发送一个恰当的确认信号给RabbitMQ。</p>
<pre><code>var consumer = new EventingBasicConsumer(channel);
</code></pre>
<p>​<br>​    consumer.Received +&#x3D; (model, ea) &#x3D;&gt;<br>​    {<br>​        var body &#x3D; ea.Body;<br>​        var message &#x3D; Encoding.UTF8.GetString(body);<br>​        Console.WriteLine(“ [x] Received {0}”, message);</p>
<p>​<br>​        int dots &#x3D; message.Split(‘.’).Length - 1;<br>​        Thread.Sleep(dots * 1000);<br>​<br>​        Console.WriteLine(“ [x] Done”);</p>
<p>​<br>​        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);<br>​    };</p>
<p>​<br>​<br>​    channel.BasicConsume(queue: “task_queue”, autoAck: false, consumer: consumer);</p>
<p>使用上面这段代码，我们可以确定的是，即使一个 Worker 在处理消息时，我们通过使用<code>CTRL + C</code>来终止它，也不会丢失任何消息。Worker 挂掉不久，所有未确认的消息将会被重新分发。</p>
<blockquote>
<p><strong>忘记确认</strong><br>遗漏<code>BasicAck</code>是一个常见的错误。这是一个很简单的错误，但导致的后果却是严重的。当客户端退出时（看起来像是随机分发的），消息将会被重新分发，但是RabbitMQ会吃掉越来越多的内存，因为它不能释放未确认的消息。<br>为了调试这种错误，您可以使用<code>rabbitmqctl</code>来打印<code>messages_unacknowledged</code>字段：</p>
<pre><code>sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
</code></pre>
<p>在Windows上，删除<code>sudo</code>：</p>
<pre><code>rabbitmqctl.bat list_queues name messages_ready messages_unacknowledged
</code></pre>
</blockquote>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化#"></a>消息持久化<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96">#</a></h2><p>我们已经学习了如何确保即使消费者挂掉，任务也不会丢失。但是如果 RabbitMQ 服务器停止，我们的任务还是会丢失。</p>
<p>当 RabbitMQ 退出或崩溃时，它会忘记已存在的队列和消息，除非告诉它不要这样做。为了确保消息不会丢失，有两件事是必须的：我们需要将队列和消息标记为<strong>持久</strong>。</p>
<p>首先，我们需要确保 RabbitMQ 永远不会丢失我们的队列。为了做到这一点，我们需要把队列声明是_持久的（Durable）_：</p>
<pre><code>// 声明队列，通过指定 durable 参数为 true，对消息进行持久化处理。 
channel.QueueDeclare(queue: &quot;hello&quot;,
                     durable: true,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);
</code></pre>
<p>虽然这个命令本身是正确的，但是它在当前设置中不会起作用。那是因为我们已经定义过一个名为<code>hello</code>的队列，并且这个队列不是持久化的。RabbitMQ 不允许使用不同的参数重新定义已经存在的队列，并会向尝试执行该操作的程序返回一个错误。但有一个快速的解决办法 - 让我们用不同的名称声明一个队列，例如<code>task_queue</code>：</p>
<pre><code>channel.QueueDeclare(queue: &quot;task_queue&quot;,
                     durable: true,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);
</code></pre>
<p>注意，该声明队列<code>QueueDeclare</code>方法的更改需要同时应用于生产者和消费者代码。</p>
<p>此时，我们可以确定的是，即使 RabbitMQ 重新启动，<code>task_queue</code>队列也不会丢失。现在我们需要将我们的消息标记为_持久的（Persistent）_ - 通过将<code>IBasicProperties.Persistent</code>设置为<code>true</code>。</p>
<pre><code>var properties = channel.CreateBasicProperties();
properties.Persistent = true;
</code></pre>
<blockquote>
<p><strong>关于消息持久性的说明</strong><br>将消息标记为<code>Persistent</code>并不能完全保证消息不会丢失。尽管它告诉 RabbitMQ 将消息保存到磁盘，但当 RabbitMQ 接收到消息并且尚未保存消息时仍有一段时间间隔。此外，RabbitMQ 不会为每条消息执行<code>fsync(2)</code> - 它可能只是保存到缓存中，并没有真正写入磁盘。消息的持久化保证并不健壮，但对于简单的任务队列来说已经足够了。如果您需要一个更加健壮的保证，可以使用 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html">发布者确认</a>。</p>
</blockquote>
<h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度#"></a>公平调度<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6">#</a></h2><p>您可能已经注意到调度仍然无法完全按照我们期望的方式工作。例如，在有两个 Worker 的情况下，假设所有奇数消息都很庞大、偶数消息都很轻量，那么一个 Worker 将会一直忙碌，而另一个 Worker 几乎不做任何工作。是的，RabbitMQ 并不知道存在这种情况，它仍然会平均地分发消息。</p>
<p>发生这种情况是因为 RabbitMQ 只是在消息进入队列后就将其分发。它不会去检查每个消费者所拥有的未确认消息的数量。它只是盲目地将第 n 条消息分发给第 n 位消费者。</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231253359-1054097198.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231253359-1054097198.png"></a></p>
<p>为了改变上述这种行为，我们可以使用参数设置<code>prefetchCount = 1</code>的<code>basicQos</code>方法。</p>
<p>这就告诉 RabbitMQ 同一时间不要给一个 Worker 发送多条消息。或者换句话说，不要向一个 Worker 发送新的消息，直到它处理并确认了前一个消息。<br>相反，它会这个消息调度给下一个不忙碌的 Worker。</p>
<pre><code>channel.BasicQos(0, 1, false);
</code></pre>
<blockquote>
<p><strong>关于队列大小的说明</strong><br>如果所有的 Worker 都很忙，您的队列可能会被填满。请留意这一点，可以尝试添加更多的 Worker，或者使用其他策略。</p>
</blockquote>
<h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起#"></a>组合在一起<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7">#</a></h2><p>我们<code>NewTask.cs</code>类的最终代码：</p>
<pre><code>using System;
using RabbitMQ.Client;
using System.Text;

class NewTask
&#123;
    public static void Main(string[] args)
    &#123;
        
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
</code></pre>
<p>​<br>​            using(var connection &#x3D; factory.CreateConnection())<br>​            using(var channel &#x3D; connection.CreateModel())<br>​            {<br>​<br>​                channel.QueueDeclare(queue: “task_queue”,<br>​                                     durable: true,<br>​                                     exclusive: false,<br>​                                     autoDelete: false,<br>​                                     arguments: null);</p>
<p>​<br>​                var message &#x3D; GetMessage(args);<br>​                var body &#x3D; Encoding.UTF8.GetBytes(message);</p>
<p>​<br>​                var properties &#x3D; channel.CreateBasicProperties();<br>​                properties.Persistent &#x3D; true;</p>
<p>​<br>​                channel.BasicPublish(exchange: “”,<br>​                                     routingKey: “task_queue”,<br>​                                     basicProperties: properties,<br>​                                     body: body);<br>​<br>​                Console.WriteLine(“ [x] Sent {0}”, message);<br>​            }<br>​<br>            Console.WriteLine(“ Press [enter] to exit.”);<br>            Console.ReadLine();<br>        }</p>
<pre><code>    private static string GetMessage(string[] args)
    &#123;
        return ((args.Length &gt; 0) ? string.Join(&quot; &quot;, args) : &quot;Hello World!&quot;);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/NewTask/NewTask.cs">（NewTask.cs 源码）</a></p>
<p>还有我们的<code>Worker.cs</code>：</p>
<pre><code>using System;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;
using System.Threading;

class Worker
&#123;
    public static void Main()
    &#123;
        
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
</code></pre>
<p>​<br>​            using(var connection &#x3D; factory.CreateConnection())<br>​            using(var channel &#x3D; connection.CreateModel())<br>​            {<br>​<br>​                channel.QueueDeclare(queue: “task_queue”,<br>​                                     durable: true,<br>​                                     exclusive: false,<br>​                                     autoDelete: false,<br>​                                     arguments: null);</p>
<p>​<br>​                channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);<br>​<br>​                Console.WriteLine(“ [*] Waiting for messages.”);</p>
<p>​<br>​                var consumer &#x3D; new EventingBasicConsumer(channel);</p>
<p>​<br>​                consumer.Received +&#x3D; (model, ea) &#x3D;&gt;<br>​                {<br>​                    var body &#x3D; ea.Body;<br>​                    var message &#x3D; Encoding.UTF8.GetString(body);<br>​                    Console.WriteLine(“ [x] Received {0}”, message);</p>
<p>​<br>​                    int dots &#x3D; message.Split(‘.’).Length - 1;<br>​                    Thread.Sleep(dots * 1000);<br>​<br>​                    Console.WriteLine(“ [x] Done”);</p>
<p>​<br>​                    channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);<br>​                };<br>​<br>​                channel.BasicConsume(queue: “task_queue”,<br>​                                     autoAck: false,<br>​                                     consumer: consumer);<br>​<br>                Console.WriteLine(“ Press [enter] to exit.”);<br>                Console.ReadLine();<br>            }<br>        }<br>    }</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Worker/Worker.cs">（Worker.cs 源码）</a></p>
<p>使用消息确认机制和<code>BasicQ</code>您可以创建一个工作队列。即使 RabbitMQ 重新启动，通过持久性选项也可让任务继续存在。</p>
<p>有关<code>IModel</code>方法和<code>IBasicProperties</code>的更多信息，您可以在线浏览 <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/releases/rabbitmq-dotnet-client/v3.6.10/rabbitmq-dotnet-client-3.6.10-client-htmldoc/html/index.html">RabbitMQ .NET客户端API参考</a>。</p>
<p>现在，我们可以继续阅读 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html">教程[3]</a>，学习如何向多个消费者发送相同的消息。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后#"></a>写在最后<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">#</a></h2><p>本文翻译自 RabbitMQ 官方教程 C# 版本。如本文介绍内容与官方有所出入，请以官方最新内容为准。水平有限，翻译的不好请见谅，如有翻译错误还请指正。</p>
<ul>
<li>原文链接：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html">RabbitMQ tutorial - Work Queues</a></li>
<li>实验环境：RabbitMQ 3.7.4 、.NET Core 2.1.2、Visual Studio Code</li>
<li>最后更新：2018-04-03</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/04/21/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/21/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">[译]RabbitMQ教程C#版 - 发布订阅</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-21 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-21T00:00:00+08:00">2018-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/" itemprop="url" rel="index"><span itemprop="name">DotNet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>先决条件</strong><br>本教程假定 RabbitMQ 已经安装，并运行在<code>localhost</code> 标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。</p>
<p><strong>从哪里获得帮助</strong><br>如果您在阅读本教程时遇到困难，可以通过邮件列表 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/rabbitmq-users">联系我们</a>。</p>
</blockquote>
<h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布&#x2F;订阅#"></a>发布&#x2F;订阅<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">#</a></h2><p><strong>（使用 .NET Client）</strong></p>
<p>在 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html">教程[2]</a> 中，我们创建了一个工作队列，假设在工作队列中的每一个任务都只被分发给一个 Worker。那么在这一章节，我们要做与之完全不同的事，那就是我们将要把一条消息分发给多个消费者。这种模式被称为“发布&#x2F;订阅”。</p>
<p>为了说明、体现这种模式，我们将会建一个简单的日志系统。它将会包含两个程序 - 第一个用来发送日志消息，第二个用来接收并打印它们。</p>
<p>在我们建立的日志系统中，每个接收程序的运行副本都会收到消息。这样我们就可以运行一个接收程序接收消息并将日志写入磁盘；同时运行另外一个接收程序接收消息并将日志打印到屏幕上。</p>
<p>实质上，发布的日志消息将会被广播给所有的接收者。</p>
<h2 id="交换器"><a href="#交换器" class="headerlink" title="交换器#"></a>交换器<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html#%E4%BA%A4%E6%8D%A2%E5%99%A8">#</a></h2><p>在教程的前几部分，我们是发送消息到队列并从队列中接收消息。现在是时候介绍 Rabbit 中完整的消息传递模型了。</p>
<p>让我们快速回顾一下前面教程中的内容：</p>
<ul>
<li>_生产者_是发送消息的用户应用程序。</li>
<li>_队列_是存储消息的缓冲区。</li>
<li>_消费者_是接收消息的用户应用程序。</li>
</ul>
<p>在 RabbitMQ 中，消息传递模型的核心理念是生产者从来不会把任何消息直接发送到队列，其实，通常生产者甚至不知道消息是否会被分发到任何队列中。</p>
<p>然而，生产者只能把消息发送给_交换器_。交换器非常简单，一方面它接收来自生产者的消息，另一方面又会把接收的消息推送到队列中。交换器必须明确知道该如何处理收到的消息，应该追加到一个特定队列中？还是应该追加到多个队列中？或者应该把它丢弃？这些规则都被定义在_交换器类型_中。</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231511453-1306601735.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231511453-1306601735.png" alt="Exchanges"></a></p>
<p>目前交换器类型有这几种：<code>direct</code>，<code>topic</code>，<code>headers</code>和<code>fanout</code>。我们先重点关注最后一个<code>fanout</code>，我们创建一个这种类型的交换器，将其命名为<code>logs</code>：</p>
<pre><code>channel.ExchangeDeclare(&quot;logs&quot;, &quot;fanout&quot;);
</code></pre>
<p><code>fanout</code>类型交换器非常简单，正如您可能从名字中猜出的那样，它会把收到的所有消息广播到它已知的所有队列中。这恰巧是我们的日志系统目前所需要的。</p>
<blockquote>
<p><strong>列举交换器</strong><br>要列举出服务器上的交换器，您可以使用非常有用的<code>rabbitmqctl</code>命令行工具：</p>
<pre><code>sudo rabbitmqctl list_exchanges
</code></pre>
<p>执行上述命令后，出现的列表中将会有一些<code>amq.*</code>交换器和默认（未命名）交换器。这些是默认创建的，不过目前您可能用不到它们。</p>
<p><strong>默认交换器</strong><br>在教程的前些部分，我们对交换器这一概念还一无所知，但仍然可以把消息发送到队列。之所以这样，是因为我们使用了一个用空字符串(<code>&quot;&quot;</code>)标识的默认交换器。</p>
<p>回顾一下我们之前如何发布消息：</p>
<pre><code>var message = GetMessage(args);
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: &quot;&quot;,
                     routingKey: &quot;hello&quot;,
                     basicProperties: null,
                     body: body);
</code></pre>
<p>第一个参数就是交换器的名称，空字符串表示默认或匿名交换器：将消息路由到<code>routingKey</code>指定的队列（如果存在）中。</p>
</blockquote>
<p>现在，我们可以把消息发布到我们指定的交换器：</p>
<pre><code>var message = GetMessage(args);
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: &quot;logs&quot;,
                     routingKey: &quot;&quot;,
                     basicProperties: null,
                     body: body);
</code></pre>
<h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列#"></a>临时队列<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html#%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97">#</a></h2><p>您是否还记得之前我们使用过的队列，它们都有一个特定的名称（记得应该是<code>hello</code>和<code>task_queue</code>吧）。给队列命名对我们来说是至关重要的 – 因为我们可能需要多个 Worker 指向同一个队列；当您想要在生产者和消费者之间共享队列时，给队列一个名称也是非常重要的。</p>
<p>但是，我们创建的日志系统并不希望如此。我们希望监听所有的日志消息，而不仅仅是其中一部分。我们也只对目前流动的消息感兴趣，而不是旧消息。为解决这个问题，我们需要做好两件事。</p>
<p>首先，我们无论何时连接 Rabbit，都需要一个新的、空的队列。要做到这一点，我们可以使用随机名称来创建队列，或许，甚至更好的方案是让服务器为我们选择一个随机队列名称。</p>
<p>其次，一旦我们与消费者断开连接，与之相关的队列应该被自动删除。</p>
<p>在 .NET 客户端中，如果不向<code>QueueDeclare()</code>方法提供任何参数，实际上就是创建了一个非持久化、独占、且自动删除的随机命名队列：</p>
<pre><code>var queueName = channel.QueueDeclare().QueueName;
</code></pre>
<p>您可以在 <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/queues.html">队列指南</a> 中了解更多关于<code>exclusive</code>参数和其他队列属性的信息。</p>
<p>此时，<code>queueName</code>包含一个随机队列名称。例如，它看起来可能像<code>amq.gen-JzTY20BRgKO-HjmUJj0wLg</code>。</p>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定#"></a>绑定<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html#%E7%BB%91%E5%AE%9A">#</a></h2><p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231544150-1057172664.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231544150-1057172664.png" alt="Bindings"></a></p>
<p>我们已经创建好了一个<code>fanout</code> 交换器和一个队列。现在我们需要告诉交换器把消息发送到我们的队列。而交换器和队列之间的关系就称之为_绑定_。</p>
<pre><code>channel.QueueBind(queue: queueName,
                  exchange: &quot;logs&quot;,
                  routingKey: &quot;&quot;);
</code></pre>
<p>从现在起，<code>logs</code>交换器会把消息追加到我们的队列中。</p>
<blockquote>
<p><strong>列举绑定</strong><br>您可以使用（您或许已经猜到了），列举出现有的绑定。</p>
<pre><code>sudo rabbitmqctl list_bindings
</code></pre>
</blockquote>
<h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起#"></a>组合在一起<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html#%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7">#</a></h2><p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231615809-832422226.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231615809-832422226.png"></a></p>
<p>生产者程序负责分发消息，这与之前的教程看起来没有太大区别。</p>
<p>最重要的变化是我们现在想把消息发布到我们的<code>logs</code>交换器，而不是匿名交换器。在发送时我们需要提供一个路由键<code>routingKey</code>，但是对于<code>fanout</code>交换器，它的值可以被忽略。这里是<code>EmitLog.cs</code>文件的代码：</p>
<pre><code>using System;
using RabbitMQ.Client;
using System.Text;

class EmitLog
&#123;
    public static void Main(string[] args)
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        &#123;
            channel.ExchangeDeclare(exchange: &quot;logs&quot;, type: &quot;fanout&quot;);

            var message = GetMessage(args);
            var body = Encoding.UTF8.GetBytes(message);
            channel.BasicPublish(exchange: &quot;logs&quot;,
                                 routingKey: &quot;&quot;,
                                 basicProperties: null,
                                 body: body);
            Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message);
        &#125;

        Console.WriteLine(&quot; Press [enter] to exit.&quot;);
        Console.ReadLine();
    &#125;

    private static string GetMessage(string[] args)
    &#123;
        return ((args.Length &gt; 0)
               ? string.Join(&quot; &quot;, args)
               : &quot;info: Hello World!&quot;);
    &#125;
&#125;
</code></pre>
<p>（<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/EmitLog/EmitLog.cs">EmitLog.cs</a> 源码）</p>
<p>如你所见，在建立连接后，我们声明了交换器。这一步非常有必要，因为发布消息到一个不存在的交换器，这种情况是被禁止的。</p>
<p>如果没有队列绑定到交换器上，消息将会丢失，但这对我们来说并没有什么没问题；如果没有消费者正在监听，我们是可以放心地把消息丢弃的。</p>
<p><code>ReceiveLogs.cs</code>的代码：</p>
<pre><code>using System;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;

class ReceiveLogs
&#123;
    public static void Main()
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        &#123;
            channel.ExchangeDeclare(exchange: &quot;logs&quot;, type: &quot;fanout&quot;);

            var queueName = channel.QueueDeclare().QueueName;
            channel.QueueBind(queue: queueName,
                              exchange: &quot;logs&quot;,
                              routingKey: &quot;&quot;);

            Console.WriteLine(&quot; [*] Waiting for logs.&quot;);

            var consumer = new EventingBasicConsumer(channel);
            consumer.Received += (model, ea) =&gt;
            &#123;
                var body = ea.Body;
                var message = Encoding.UTF8.GetString(body);
                Console.WriteLine(&quot; [x] &#123;0&#125;&quot;, message);
            &#125;;
            channel.BasicConsume(queue: queueName,
                                 autoAck: true,
                                 consumer: consumer);

            Console.WriteLine(&quot; Press [enter] to exit.&quot;);
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<p>（<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/ReceiveLogs/ReceiveLogs.cs">ReceiveLogs.cs</a> 源码）</p>
<p>按照 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html">教程[1]</a>中的设置说明生成<code>EmitLogs</code>和<code>ReceiveLogs</code> 项目。</p>
<p>如果您想把日志保存到文件中，只需打开一个控制台并输入：</p>
<pre><code>cd ReceiveLogs
dotnet run &gt; logs_from_rabbit.log
</code></pre>
<p>如果你想在屏幕上看到日志，我可以新开一个终端并运行：</p>
<pre><code>cd ReceiveLogs
dotnet run
</code></pre>
<p>当然，分发日志需要输入：</p>
<pre><code>cd EmitLog
dotnet run
</code></pre>
<p>使用<code>rabbitmqctl list_bindings</code>命令，您可以验证代码是否真正创建了我们想要的绑定和队列。当有两<code>个ReceiveLogs.cs</code>程序运行时，您应该看到如下所示的内容：</p>
<pre><code>sudo rabbitmqctl list_bindings
</code></pre>
<p>​<br>​<br>​<br>​    </p>
<p>对执行结果的解释简洁明了：来自<code>logs</code>交换器的数据转发到了两个由服务器随机分配名称的队列。这正是我们期待的结果。</p>
<p>想要了解如何监听消息的这一块内容，让我们继续阅读 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-routing.html">教程[4]</a>。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后#"></a>写在最后<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-publish-subscribe.html#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">#</a></h2><p>本文翻译自 RabbitMQ 官方教程 C# 版本。如本文介绍内容与官方有所出入，请以官方最新内容为准。水平有限，翻译的不好请见谅，如有翻译错误还请指正。</p>
<ul>
<li>原文链接：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-three-dotnet.html">RabbitMQ tutorial - Publish&#x2F;Subscribe</a></li>
<li>实验环境：RabbitMQ 3.7.4 、.NET Core 2.1.3、Visual Studio Code</li>
<li>最后更新：2018-06-11</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://chengming0916.github.io/2018/04/14/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20Hello%20World/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chemmy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Chemmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/14/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/RabbitMQ%E6%95%99%E7%A8%8BC#%E7%89%88%20-%20Hello%20World/" class="post-title-link" itemprop="url">[译]RabbitMQ教程C#版 - Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-14T00:00:00+08:00">2018-04-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 16:58:11" itemprop="dateModified" datetime="2025-12-04T16:58:11+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">编程技术</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/DotNet/" itemprop="url" rel="index"><span itemprop="name">DotNet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<blockquote>
<p><strong>先决条件</strong><br>本教程假定 RabbitMQ 已经安装，并运行在<code>localhost</code> 标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。</p>
</blockquote>
<p><strong>从哪里获得帮助</strong><br>如果您在阅读本教程时遇到困难，可以通过邮件列表 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/rabbitmq-users">联系我们</a>。</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍#"></a>介绍<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#%E4%BB%8B%E7%BB%8D">#</a></h2><p>RabbitMQ 是一个消息中间件：它接收并转发消息。您可以把它想象为一个邮局：当您把需要寄出的邮件投递到邮箱，邮差最终会把邮件送给您的收件人。在这个比喻中，RabbitMQ 就是一个邮箱，也可以理解成邮局和邮递员。</p>
<p>RabbitMQ 和邮局的主要区别在于它不处理纸张，而是接收、存储和转发二进制数据块 - _<strong>消息</strong>_。</p>
<p>RabbitMQ 和消息传递通常使用一些术语。</p>
<p><em><strong>生产</strong></em> 的意思无非就是发送。发送消息的程序就是一个 _<strong>生产者</strong>_：</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230040114-1725657053.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230040114-1725657053.png" alt="Producer"></a></p>
<p><em><strong>队列</strong></em> 就是 RabbitMQ 内部“邮箱”的名称。虽然消息流经 RabbitMQ 和您的应用程序，但它们只能存储在 <em><strong>队列</strong></em> 中。_<strong>队列</strong>_ 只受主机的内存和磁盘的限制，它本质上就是一个很大的消息缓冲区。多个 <em><strong>生产者</strong></em> 可以发送消息到一个队列，并且多个 <em><strong>消费者</strong></em> 可以尝试从一个 <em><strong>队列</strong></em> 接收数据。这就是我们代表队列的方式：</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230222640-301693279.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230222640-301693279.png" alt="Queue"></a></p>
<p><em><strong>消费</strong></em> 与接收有相似的含义，等待接收消息的程序就是一个 _<strong>消费者</strong>_：</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230333180-2050010801.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230333180-2050010801.png" alt="Consumer"></a></p>
<blockquote>
<p>注意：生产者、消费者和中间件不是必须部署在同一主机上，实际上在大多数应用程序中它们也不是这样的。</p>
</blockquote>
<h2 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”#"></a>“Hello World”<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#hello-world">#</a></h2><p><strong>使用 .NET &#x2F; C＃Client</strong></p>
<p>在教程的这一部分，我们将用 C＃ 编写两个程序：一个发送单条消息的生产者，以及接收消息并将其打印出来的消费者。我们将忽略 .NET 客户端 API 中的一些细节，专注于更简单的开始。这是一个消息传递的“Hello World”。</p>
<p>在下图中，<code>P</code>是我们的生产者，<code>C</code>是我们的消费者。中间的盒子是队列 - RabbitMQ 代表消费者保存的消息缓冲区。</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230602905-137147155.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230602905-137147155.png"></a></p>
<blockquote>
<p><strong>.NET 客户端库</strong></p>
<p>RabbitMQ 支持多种协议，本教程使用<code>AMQP 0-9-1</code>，它是一种开放的、通用的消息传递协议。RabbitMQ 提供了一些针对不同 <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/devtools.html">语言环境</a> 的客户端，我们将使用 RabbitMQ 提供的 .NET 客户端。</p>
<p>客户端支持 <a target="_blank" rel="noopener" href="https://www.microsoft.com/net/learn/get-started/windows">.NET Core</a> 以及 .NET Framework 4.5.1+。本教程将使用 .NET Core，因此您需要确保客户端已 <a target="_blank" rel="noopener" href="https://www.microsoft.com/net/learn/get-started/windows">安装</a> 并且路径添加到<code>PATH</code>系统变量。</p>
<p>您也可以使用 .NET Framework 来完成本教程，但设置步骤会有所不同。</p>
<p>RabbitMQ .NET 客户端 5.0 及更高版本通过 <a target="_blank" rel="noopener" href="https://www.nuget.org/packages/RabbitMQ.Client">nuget</a> 发布。</p>
<p>本教程假定您在 Windows 上使用 PowerShell。在 MacOS 和 Linux 上，几乎所有 shell 也都可以正常工作。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装#"></a>安装<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#%E5%AE%89%E8%A3%85">#</a></h3><p>首先让我们验证您在<code>PATH</code>系统变量是否有 .NET Core 工具链：</p>
<pre><code>dotnet --help
</code></pre>
<p>应该产生帮助信息。</p>
<p>现在，让我们生成两个项目，一个用于发布者，另一个用于消费者：</p>
<pre><code>dotnet new console --name Send
mv Send/Program.cs Send/Send.cs
dotnet new console --name Receive
mv Receive/Program.cs Receive/Receive.cs
</code></pre>
<p>这将创建两个名为<code>Send</code>和<code>Receive</code>的新目录。</p>
<p>然后，我们添加客户端依赖项。</p>
<pre><code>cd Send
dotnet add package RabbitMQ.Client
dotnet restore
cd ../Receive
dotnet add package RabbitMQ.Client
dotnet restore
</code></pre>
<p>我们已经建立了 .NET 项目，现在我们可以编写一些代码。</p>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送#"></a>发送<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#%E5%8F%91%E9%80%81">#</a></h3><p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230729567-488325508.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117230729567-488325508.png"></a></p>
<p>我们将调用我们的消息发布者（发送者）<code>Send.cs</code>和我们的消息消费者（接收者）<code>Receive.cs</code>。发布者将连接到 RabbitMQ，发送一条消息，然后退出。</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Send/Send.cs">Send.cs</a> 中，我们需要使用一些命名空间：</p>
<pre><code>using System;
using RabbitMQ.Client;
using System.Text;
</code></pre>
<p>设置类：</p>
<pre><code>class Send
&#123;
    public static void Main()
    &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>然后，我们可以创建一个连接，连接到服务器：</p>
<pre><code>class Send
&#123;
    public static void Main()
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using (var connection = factory.CreateConnection())
        &#123;
            using (var channel = connection.CreateModel())
            &#123;
                ...
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>该连接抽象了套接字连接，并为我们处理协议版本的协商和身份验证等。在这里，我们连接的是本地机器上的代理， 因此是<code>localhost</code>。如果我们想连接到其他机器上的代理，我们只需在此指定其名称或 IP 地址。</p>
<p>接下来，我们创建一个通道，该 API 的主要功能是把获得信息保存起来。</p>
<p>想要发送消息，我们必须为需要发送的消息声明一个队列，然后我们就可以把消息发布到队列中：</p>
<pre><code>using System;
using RabbitMQ.Client;
using System.Text;

class Send
&#123;
    public static void Main()
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        &#123;
            channel.QueueDeclare(queue: &quot;hello&quot;,
                                 durable: false,
                                 exclusive: false,
                                 autoDelete: false,
                                 arguments: null);

            string message = &quot;Hello World!&quot;;
            var body = Encoding.UTF8.GetBytes(message);

            channel.BasicPublish(exchange: &quot;&quot;,
                                 routingKey: &quot;hello&quot;,
                                 basicProperties: null,
                                 body: body);
            Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message);
        &#125;

        Console.WriteLine(&quot; Press [enter] to exit.&quot;);
        Console.ReadLine();
    &#125;
&#125;
</code></pre>
<p>声明队列是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%82%E7%AD%89/8600688?fr=aladdin">幂等</a> 的 - 只有当它不存在时才会被创建。消息内容是一个字节数组，所以您可以用喜欢的任意方式编码。</p>
<p>当上面的代码完成运行时，通道和连接将被释放。这就是我们的发布者。</p>
<p>（<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Send/Send.cs">Send.cs</a> 源码）</p>
<blockquote>
<p><strong>发送不起作用！</strong></p>
<p>如果这是您第一次使用 RabbitMQ，并且您没有看到“已发送”消息，那么您可能会挠着头想知道错误出在什么地方。也许是代理程序启动时没有足够的可用磁盘空间（默认情况下，它至少需要50 MB空闲空间），因此拒绝接收消息。<br>必要时检查代理程序日志文件来确认和减少限制。配置文件 <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/configure.html#config-items">文档</a> 将告诉您如何设置<code>disk_free_limit</code>。</p>
</blockquote>
<h3 id="接收"><a href="#接收" class="headerlink" title="接收#"></a>接收<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#%E6%8E%A5%E6%94%B6">#</a></h3><p>至于消费者，它是把消息从 RabbitMQ 拉取过来。因此，与发布消息的发布者不同，我们会保持消费者持续不断地运行，监听消息并将其打印出来。</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231003983-2037680750.png"><img src="https://img2018.cnblogs.com/blog/785976/201811/785976-20181117231003983-2037680750.png"></a></p>
<p>代码（在 <a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Receive/Receive.cs">Receive.cs</a> 中）具有与<code>Send</code>差不多一样的<code>using</code>声明：</p>
<pre><code>using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System;
using System.Text;
</code></pre>
<p>设置与发布者相同；我们开启一个连接和一个通道，并声明我们将要使用的队列。请注意，这需要与<code>Send</code>发布到的队列相匹配。</p>
<pre><code>class Receive
&#123;
    public static void Main()
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using (var connection = factory.CreateConnection())
        &#123;
            using (var channel = connection.CreateModel())
            &#123;
                channel.QueueDeclare(queue: &quot;hello&quot;,
                                     durable: false,
                                     exclusive: false,
                                     autoDelete: false,
                                     arguments: null);
                ...
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>请注意，我们在这里也声明了队列。因为我们可能会在发布者之前启动消费者，所以我们希望在我们尝试从它中消费消息之前确保队列已存在。</p>
<p>我们即将告诉服务器将队列中的消息传递给我们。由于它会异步推送消息，因此我们提供了一个回调。这就是<code>EventingBasicConsumer.Received</code>事件处理程序所做的事情。</p>
<pre><code>using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System;
using System.Text;

class Receive
&#123;
    public static void Main()
    &#123;
        var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        &#123;
            channel.QueueDeclare(queue: &quot;hello&quot;,
                                 durable: false,
                                 exclusive: false,
                                 autoDelete: false,
                                 arguments: null);

            var consumer = new EventingBasicConsumer(channel);
            consumer.Received += (model, ea) =&gt;
            &#123;
                var body = ea.Body;
                var message = Encoding.UTF8.GetString(body);
                Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);
            &#125;;
            channel.BasicConsume(queue: &quot;hello&quot;,
                                 autoAck: true,
                                 consumer: consumer);

            Console.WriteLine(&quot; Press [enter] to exit.&quot;);
            Console.ReadLine();
        &#125;
    &#125;
&#125;
</code></pre>
<p>（<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Receive/Receive.cs">Receive.cs</a> 源码）</p>
<h3 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起#"></a>组合在一起<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7">#</a></h3><p>打开两个终端。</p>
<p>运行消费者：</p>
<pre><code>cd Receive
dotnet run
</code></pre>
<p>运行生产者：</p>
<pre><code>cd Send
dotnet run
</code></pre>
<p>消费者将打印它通过 RabbitMQ 从发布者处获得的消息。消费者将继续运行、等待新消息（按<code>Ctrl-C</code>将其停止），可以尝试从开启另一个终端运行发布者。</p>
<p>接下来可以跳转到 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html/">教程[2]</a>，构建一个简单的工作队列。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后#"></a>写在最后<a target="_blank" rel="noopener" href="https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">#</a></h2><p>本文翻译自 RabbitMQ 官方教程 C# 版本。如本文介绍内容与官方有所出入，请以官方最新内容为准。水平有限，翻译的不好请见谅，如有翻译错误还请指正。</p>
<ul>
<li>原文链接：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-one-dotnet.html">RabbitMQ tutorial - “Hello World!”</a></li>
<li>实验环境：RabbitMQ 3.7.4 、.NET Core 2.1.3、Visual Studio Code</li>
<li>最后更新：2018-03-13</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Chemmy</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"chengming0916/chengming0916.github.io","repo_id":"R_kgDOLemcag","category":"Announcements","category_id":"DIC_kwDOLemcas4CupMn","mapping":"title","strict":0,"reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
